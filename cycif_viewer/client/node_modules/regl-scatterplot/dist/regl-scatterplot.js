(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('pub-sub-es'), require('regl')) :
  typeof define === 'function' && define.amd ? define(['exports', 'pub-sub-es', 'regl'], factory) :
  (global = global || self, factory(global.createScatterplot = {}, global.createPubSub, global.createREGL));
}(this, (function (exports, createPubSub, createOriginalRegl) { 'use strict';

  createPubSub = createPubSub && Object.prototype.hasOwnProperty.call(createPubSub, 'default') ? createPubSub['default'] : createPubSub;
  createOriginalRegl = createOriginalRegl && Object.prototype.hasOwnProperty.call(createOriginalRegl, 'default') ? createOriginalRegl['default'] : createOriginalRegl;

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */

  function clone(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function invert(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function multiply(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$1() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create$1();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create$2() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Get the angle between two 2D vectors
   * @param {ReadonlyVec2} a The first operand
   * @param {ReadonlyVec2} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle(a, b) {
    var x1 = a[0],
        y1 = a[1],
        x2 = b[0],
        y2 = b[1],
        // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
        // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$2();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  }();

  const createCamera = (initTarget = [0, 0], initDistance = 1, initRotation = 0, initViewCenter = [0, 0], initScaleBounds = [0, Infinity]) => {
    // Scratch variables
    const scratch0 = new Float32Array(16);
    const scratch1 = new Float32Array(16);
    const scratch2 = new Float32Array(16);
    let view = create();
    let viewCenter = [...initViewCenter.slice(0, 2), 0, 1];
    const scaleBounds = [...initScaleBounds];

    const getRotation = () => Math.acos(view[0] / getScaling$1());

    const getScaling$1 = () => getScaling(scratch0, view)[0];

    const getScaleBounds = () => [...scaleBounds];

    const getDistance = () => 1 / getScaling$1();

    const getTranslation$1 = () => getTranslation(scratch0, view).slice(0, 2);

    const getTarget = () => transformMat4(scratch0, viewCenter, invert(scratch2, view)).slice(0, 2);

    const getView = () => view;

    const getViewCenter = () => viewCenter.slice(0, 2);

    const lookAt = ([x = 0, y = 0] = [], newDistance = 1, newRotation = 0) => {
      // Reset the view
      view = create();
      translate([-x, -y]);
      rotate(newRotation);
      scale(1 / newDistance);
    };

    const translate = ([x = 0, y = 0] = []) => {
      scratch0[0] = x;
      scratch0[1] = y;
      scratch0[2] = 0;
      const t = fromTranslation(scratch1, scratch0); // Translate about the viewport center
      // This is identical to `i * t * i * view` where `i` is the identity matrix

      multiply(view, t, view);
    };

    const scale = (d, mousePos) => {
      if (d <= 0) return;
      const scale = getScaling$1();
      const newScale = scale * d;
      d = Math.max(scaleBounds[0], Math.min(newScale, scaleBounds[1])) / scale;
      if (d === 1) return; // There is nothing to do

      scratch0[0] = d;
      scratch0[1] = d;
      scratch0[2] = 1;
      const s = fromScaling(scratch1, scratch0);
      const scaleCenter = mousePos ? [...mousePos, 0] : viewCenter;
      const a = fromTranslation(scratch0, scaleCenter); // Translate about the scale center
      // I.e., the mouse position or the view center

      multiply(view, a, multiply(view, s, multiply(view, invert(scratch2, a), view)));
    };

    const rotate = rad => {
      const r = create();
      fromRotation(r, rad, [0, 0, 1]); // Rotate about the viewport center
      // This is identical to `i * r * i * view` where `i` is the identity matrix

      multiply(view, r, view);
    };

    const setScaleBounds = newBounds => {
      scaleBounds[0] = newBounds[0];
      scaleBounds[1] = newBounds[1];
    };

    const setView = newView => {
      if (!newView || newView.length < 16) return;
      view = newView;
    };

    const setViewCenter = newViewCenter => {
      viewCenter = [...newViewCenter.slice(0, 2), 0, 1];
    };

    const reset = () => {
      lookAt(initTarget, initDistance, initRotation);
    }; // Init


    lookAt(initTarget, initDistance, initRotation);
    return {
      get translation() {
        return getTranslation$1();
      },

      get target() {
        return getTarget();
      },

      get scaling() {
        return getScaling$1();
      },

      get scaleBounds() {
        return getScaleBounds();
      },

      get distance() {
        return getDistance();
      },

      get rotation() {
        return getRotation();
      },

      get view() {
        return getView();
      },

      get viewCenter() {
        return getViewCenter();
      },

      lookAt,
      translate,
      pan: translate,
      rotate,
      scale,
      zoom: scale,
      reset,
      set: (...args) => {
        console.warn("`set()` is deprecated. Please use `setView()` instead.");
        return setView(...args);
      },
      setScaleBounds,
      setView,
      setViewCenter
    };
  };

  const dom2dCamera = (element, {
    distance = 1.0,
    target = [0, 0],
    rotation = 0,
    isNdc = true,
    isFixed = false,
    isPan = true,
    panSpeed = 1,
    isRotate = true,
    rotateSpeed = 1,
    isZoom = true,
    zoomSpeed = 1,
    viewCenter,
    scaleBounds,
    onKeyDown = () => {},
    onKeyUp = () => {},
    onMouseDown = () => {},
    onMouseUp = () => {},
    onMouseMove = () => {},
    onWheel = () => {}
  } = {}) => {
    let camera = createCamera(target, distance, rotation, viewCenter, scaleBounds);
    let isChanged = false;
    let mouseX = 0;
    let mouseY = 0;
    let prevMouseX = 0;
    let prevMouseY = 0;
    let isLeftMousePressed = false;
    let yScroll = 0;
    let top = 0;
    let left = 0;
    let width = 1;
    let height = 1;
    let aspectRatio = 1;
    let isAlt = false;
    const transformPanX = isNdc ? dX => dX / width * 2 * aspectRatio // to normalized device coords
    : dX => dX;
    const transformPanY = isNdc ? dY => dY / height * 2 // to normalized device coords
    : dY => -dY;
    const transformScaleX = isNdc ? x => (-1 + x / width * 2) * aspectRatio // to normalized device coords
    : x => x;
    const transformScaleY = isNdc ? y => 1 - y / height * 2 // to normalized device coords
    : y => y;

    const tick = () => {
      if (isFixed) return false;
      isChanged = false;

      if (isPan && isLeftMousePressed && !isAlt) {
        // To pan 1:1 we need to half the width and height because the uniform
        // coordinate system goes from -1 to 1.
        camera.pan([transformPanX(panSpeed * (mouseX - prevMouseX)), transformPanY(panSpeed * (prevMouseY - mouseY))]);
        isChanged = true;
      }

      if (isZoom && yScroll) {
        const dZ = zoomSpeed * Math.exp(yScroll / height); // Get normalized device coordinates (NDC)

        const transformedX = transformScaleX(mouseX);
        const transformedY = transformScaleY(mouseY);
        camera.scale(1 / dZ, [transformedX, transformedY]);
        isChanged = true;
      }

      if (isRotate && isLeftMousePressed && isAlt) {
        const wh = width / 2;
        const hh = height / 2;
        const x1 = prevMouseX - wh;
        const y1 = hh - prevMouseY;
        const x2 = mouseX - wh;
        const y2 = hh - mouseY; // Angle between the start and end mouse position with respect to the
        // viewport center

        const radians = angle([x1, y1], [x2, y2]); // Determine the orientation

        const cross = x1 * y2 - x2 * y1;
        camera.rotate(rotateSpeed * radians * Math.sign(cross));
        isChanged = true;
      } // Reset scroll delta and mouse position


      yScroll = 0;
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      return isChanged;
    };

    const config = ({
      isFixed: newIsFixed = null,
      isPan: newIsPan = null,
      isRotate: newIsRotate = null,
      isZoom: newIsZoom = null,
      panSpeed: newPanSpeed = null,
      rotateSpeed: newRotateSpeed = null,
      zoomSpeed: newZoomSpeed = null
    } = {}) => {
      isFixed = newIsFixed !== null ? newIsFixed : isFixed;
      isPan = newIsPan !== null ? newIsPan : isPan;
      isRotate = newIsRotate !== null ? newIsRotate : isRotate;
      isZoom = newIsZoom !== null ? newIsZoom : isZoom;
      panSpeed = +newPanSpeed > 0 ? newPanSpeed : panSpeed;
      rotateSpeed = +newRotateSpeed > 0 ? newRotateSpeed : rotateSpeed;
      zoomSpeed = +newZoomSpeed > 0 ? newZoomSpeed : zoomSpeed;
    };

    const refresh = () => {
      const bBox = element.getBoundingClientRect();
      top = bBox.top;
      left = bBox.left;
      width = bBox.width;
      height = bBox.height;
      aspectRatio = width / height;
    };

    const keyUpHandler = event => {
      isAlt = false;
      onKeyUp(event);
    };

    const keyDownHandler = event => {
      isAlt = event.altKey;
      onKeyDown(event);
    };

    const mouseUpHandler = event => {
      isLeftMousePressed = false;
      onMouseUp(event);
    };

    const mouseDownHandler = event => {
      isLeftMousePressed = event.buttons === 1;
      onMouseDown(event);
    };

    const mouseMoveHandler = event => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = event.clientX - left;
      mouseY = event.clientY - top;
      onMouseMove(event);
    };

    const wheelHandler = event => {
      event.preventDefault();
      const scale = event.deltaMode === 1 ? 12 : 1;
      yScroll += scale * (event.deltaY || 0);
      onWheel(event);
    };

    const dispose = () => {
      camera = undefined;
      window.removeEventListener("keydown", keyDownHandler);
      window.removeEventListener("keyup", keyUpHandler);
      element.removeEventListener("mousedown", mouseDownHandler);
      window.removeEventListener("mouseup", mouseUpHandler);
      window.removeEventListener("mousemove", mouseMoveHandler);
      element.removeEventListener("wheel", wheelHandler);
    };

    window.addEventListener("keydown", keyDownHandler, {
      passive: true
    });
    window.addEventListener("keyup", keyUpHandler, {
      passive: true
    });
    element.addEventListener("mousedown", mouseDownHandler, {
      passive: true
    });
    window.addEventListener("mouseup", mouseUpHandler, {
      passive: true
    });
    window.addEventListener("mousemove", mouseMoveHandler, {
      passive: true
    });
    element.addEventListener("wheel", wheelHandler, {
      passive: false
    });
    refresh();
    camera.config = config;
    camera.dispose = dispose;
    camera.refresh = refresh;
    camera.tick = tick;
    return camera;
  };

  function sortKD(ids, coords, nodeSize, left, right, depth) {
    if (right - left <= nodeSize) return;
    const m = left + right >> 1;
    select(ids, coords, m, left, right, depth % 2);
    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
  }

  function select(ids, coords, k, left, right, inc) {
    while (right > left) {
      if (right - left > 600) {
        const n = right - left + 1;
        const m = k - left + 1;
        const z = Math.log(n);
        const s = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
        const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
        select(ids, coords, k, newLeft, newRight, inc);
      }

      const t = coords[2 * k + inc];
      let i = left;
      let j = right;
      swapItem(ids, coords, left, k);
      if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);

      while (i < j) {
        swapItem(ids, coords, i, j);
        i++;
        j--;

        while (coords[2 * i + inc] < t) i++;

        while (coords[2 * j + inc] > t) j--;
      }

      if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);else {
        j++;
        swapItem(ids, coords, j, right);
      }
      if (j <= k) left = j + 1;
      if (k <= j) right = j - 1;
    }
  }

  function swapItem(ids, coords, i, j) {
    swap(ids, i, j);
    swap(coords, 2 * i, 2 * j);
    swap(coords, 2 * i + 1, 2 * j + 1);
  }

  function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }

  function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
    const stack = [0, ids.length - 1, 0];
    const result = [];
    let x, y;

    while (stack.length) {
      const axis = stack.pop();
      const right = stack.pop();
      const left = stack.pop();

      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          x = coords[2 * i];
          y = coords[2 * i + 1];
          if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
        }

        continue;
      }

      const m = Math.floor((left + right) / 2);
      x = coords[2 * m];
      y = coords[2 * m + 1];
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);
      const nextAxis = (axis + 1) % 2;

      if (axis === 0 ? minX <= x : minY <= y) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(nextAxis);
      }

      if (axis === 0 ? maxX >= x : maxY >= y) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(nextAxis);
      }
    }

    return result;
  }

  function within(ids, coords, qx, qy, r, nodeSize) {
    const stack = [0, ids.length - 1, 0];
    const result = [];
    const r2 = r * r;

    while (stack.length) {
      const axis = stack.pop();
      const right = stack.pop();
      const left = stack.pop();

      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
        }

        continue;
      }

      const m = Math.floor((left + right) / 2);
      const x = coords[2 * m];
      const y = coords[2 * m + 1];
      if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);
      const nextAxis = (axis + 1) % 2;

      if (axis === 0 ? qx - r <= x : qy - r <= y) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(nextAxis);
      }

      if (axis === 0 ? qx + r >= x : qy + r >= y) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(nextAxis);
      }
    }

    return result;
  }

  function sqDist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
  }

  const defaultGetX = p => p[0];

  const defaultGetY = p => p[1];

  class KDBush {
    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {
      this.nodeSize = nodeSize;
      this.points = points;
      const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;
      const ids = this.ids = new IndexArrayType(points.length);
      const coords = this.coords = new ArrayType(points.length * 2);

      for (let i = 0; i < points.length; i++) {
        ids[i] = i;
        coords[2 * i] = getX(points[i]);
        coords[2 * i + 1] = getY(points[i]);
      }

      sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
    }

    range(minX, minY, maxX, maxY) {
      return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
    }

    within(x, y, r) {
      return within(this.ids, this.coords, x, y, r, this.nodeSize);
    }

  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = freeGlobal || freeSelf || Function('return this')();

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */

  var now = function () {
    return root.Date.now();
  };

  /** Built-in value references. */

  var Symbol$1 = root.Symbol;

  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }

  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max,
      nativeMin = Math.min;
  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */

  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    wait = toNumber(wait) || 0;

    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time; // Start the timer for the trailing edge.

      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /** Error message constants. */

  var FUNC_ERROR_TEXT$1 = 'Expected a function';
  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */

  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }

    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  /**
   * Higher order function for request animation frame-based throttling. If you
   * call the wrapped function multiple times, the last argument will be used the
   * next time a frame is available.
   * @param {function} fn - Function to be throttled
   * @param {function} onCall - Callback function, which is triggered with the
   *   return value of `fn`.
   * @param {function} raf - Request animation frame polyfill. Defaults to
   *   `window.requestAnimationFrame`.
   * @return {function} Throttled function `fn` which returns the request ID that
   *   can be used to cancel the request.
   */
  const withRaf = (fn, onCall, raf = window.requestAnimationFrame) => {
    let isRequesting = false;
    let requestedArgs;
    return (...args) => {
      requestedArgs = args;
      if (isRequesting) return undefined;
      isRequesting = true;
      return raf(() => {
        const response = fn(...requestedArgs);
        isRequesting = false;
        if (onCall) onCall(response);
      });
    };
  };

  const FRAGMENT_SHADER = `
precision mediump float;
uniform vec4 color;
void main() {
  gl_FragColor = color;
}`;

  // Vertex shader from https://mattdesl.svbtle.com/drawing-lines-is-hard
  // The MIT License (MIT) Copyright (c) 2015 Matt DesLauriers
  const VERTEX_SHADER = `
uniform mat4 projection;
uniform mat4 model;
uniform mat4 view;
uniform float aspectRatio;

uniform float width;
uniform int miter;

attribute vec3 prevPosition;
attribute vec3 currPosition;
attribute vec3 nextPosition;
attribute float offsetScale;

void main() {
  vec2 aspectVec = vec2(aspectRatio, 1.0);
  mat4 projViewModel = projection * view * model;
  vec4 prevProjected = projViewModel * vec4(prevPosition, 1.0);
  vec4 currProjected = projViewModel * vec4(currPosition, 1.0);
  vec4 nextProjected = projViewModel * vec4(nextPosition, 1.0);

  // get 2D screen space with W divide and aspect correction
  vec2 prevScreen = prevProjected.xy / prevProjected.w * aspectVec;
  vec2 currScreen = currProjected.xy / currProjected.w * aspectVec;
  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;

  // starting point uses (next - current)
  vec2 dir = vec2(0.0);
  if (currScreen == prevScreen) {
    dir = normalize(nextScreen - currScreen);
  }
  // ending point uses (current - previous)
  else if (currScreen == nextScreen) {
    dir = normalize(currScreen - prevScreen);
  }
  // somewhere in middle, needs a join
  else {
    // get directions from (C - B) and (B - A)
    vec2 dirA = normalize((currScreen - prevScreen));
    if (miter == 1) {
      vec2 dirB = normalize((nextScreen - currScreen));
      // now compute the miter join normal and length
      vec2 tangent = normalize(dirA + dirB);
      vec2 perp = vec2(-dirA.y, dirA.x);
      vec2 miter = vec2(-tangent.y, tangent.x);
      dir = tangent;
    } else {
      dir = dirA;
    }
  }

  vec2 normal = vec2(-dir.y, dir.x) * width;
  normal.x /= aspectRatio;
  vec4 offset = vec4(normal * offsetScale, 0.0, 0.0);
  gl_Position = currProjected + offset;
}`;

  const {
    push,
    unshift
  } = Array.prototype;
  const I = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  const FLOAT_BYTES = Float32Array.BYTES_PER_ELEMENT;

  const createMesh = (numPoints, width, buffer = []) => {
    for (let i = 0; i < numPoints - 1; i++) {
      const a = width + i * 2;
      const b = a + 1;
      const c = a + 2;
      const d = a + 3;
      buffer.push(a, b, c, c, b, d);
    }

    return buffer;
  };

  const buffer = {
    duplicate(buffer, stride = 1, dupScale = 1) {
      const out = [];
      const component = new Array(stride * 2);

      for (let i = 0, il = buffer.length / stride; i < il; i++) {
        const index = i * stride;

        for (let j = 0; j < stride; j++) {
          const value = buffer[index + j];
          component[j] = value;
          component[j + stride] = value * dupScale;
        }

        push.apply(out, component);
      }

      return out;
    },

    mapElement(buffer, elementIndex, stride, map) {
      for (let i = 0, il = buffer.length / stride; i < il; i++) {
        const index = elementIndex + i * stride;
        buffer[index] = map(buffer[index], index, i);
      }

      return buffer;
    },

    pushElement(buffer, elementIndex, stride) {
      const component = new Array(stride);
      const ai = elementIndex * stride;

      for (let i = 0; i < stride; i++) {
        component[i] = buffer[ai + i];
      }

      push.apply(buffer, component);
      return buffer;
    },

    // Copy a component to the beginning of the buffer
    unshiftElement(buffer, elementIndex, stride) {
      const component = new Array(stride);
      const ai = elementIndex * stride;

      for (let i = 0; i < stride; i++) {
        component[i] = buffer[ai + i];
      }

      unshift.apply(buffer, component);
      return buffer;
    },

    increaseStride(buffer, stride, newStride, undefValue = 0) {
      const out = [];
      const component = new Array(newStride).fill(undefValue);

      for (let i = 0, il = buffer.length / stride; i < il; i++) {
        const index = i * stride;

        for (let j = 0; j < stride; j++) {
          component[j] = buffer[index + j];
        }

        push.apply(out, component);
      }

      return out;
    }

  };

  const createLine = (regl, {
    projection = I,
    model = I,
    view = I,
    points = [],
    widths = [],
    color = [0.8, 0.5, 0, 1],
    width = 1,
    miter = 1,
    is2d = false,
    zPos2d = 0
  } = {}) => {
    if (!regl) {
      console.error("Regl instance is undefined.");
      return;
    }

    let numPoints;
    let numPointsTotal;
    let pointsPadded;
    let pointsDup;
    let widthsDup;
    let indices;
    let pointBuffer;
    let widthBuffer;
    let attributes;
    let elements;
    let drawLine;
    let dim = is2d ? 2 : 3;

    const init = () => {
      pointBuffer = regl.buffer();
      widthBuffer = regl.buffer();
      attributes = {
        prevPosition: {
          buffer: () => pointBuffer,
          offset: 0,
          stride: FLOAT_BYTES * 3
        },
        currPosition: {
          buffer: () => pointBuffer,
          // note that each point is duplicated, hence we need to skip over the first two
          offset: FLOAT_BYTES * 3 * 2,
          stride: FLOAT_BYTES * 3
        },
        nextPosition: {
          buffer: () => pointBuffer,
          // note that each point is duplicated, hence we need to skip over the first four
          offset: FLOAT_BYTES * 3 * 4,
          stride: FLOAT_BYTES * 3
        },
        offsetScale: () => widthBuffer
      };
      elements = regl.elements();
      drawLine = regl({
        attributes,
        depth: {
          enable: !is2d
        },
        blend: {
          enable: true,
          func: {
            srcRGB: "src alpha",
            srcAlpha: "one",
            dstRGB: "one minus src alpha",
            dstAlpha: "one minus src alpha"
          }
        },
        uniforms: {
          projection: (context, props) => context.projection || props.projection,
          model: (context, props) => context.model || props.model,
          view: (context, props) => context.view || props.view,
          aspectRatio: ({
            viewportWidth,
            viewportHeight
          }) => viewportWidth / viewportHeight,
          color: () => color,
          width: ({
            viewportWidth
          }) => width / viewportWidth * window.devicePixelRatio,
          miter
        },
        elements: () => elements,
        vert: VERTEX_SHADER,
        frag: FRAGMENT_SHADER
      });
    };

    const prepare = () => {
      if (points.length % dim > 0) {
        console.warn(`The length of points (${numPoints}) does not match the dimensions (${dim}). Incomplete points are ignored.`);
      } // Copy all points belonging to complete points


      pointsPadded = points.slice(0, numPoints * dim); // Add the missing z point

      if (is2d) {
        pointsPadded = buffer.increaseStride(pointsPadded, 2, 3, zPos2d);
      }

      if (widths.length !== numPoints) widths = new Array(numPoints).fill(1); // duplicate the first and last point. E.g., [1,2,3] -> [1,1,2,3,3]
      // copy the last point to the end

      buffer.pushElement(pointsPadded, numPoints - 1, 3); // copy the first point to the beginning

      buffer.unshiftElement(pointsPadded, 0, 3); // duplicate each point for the positive and negative width (see below)

      pointsDup = new Float32Array(buffer.duplicate(pointsPadded, 3)); // duplicate each width such that we have a positive and negative width

      widthsDup = buffer.duplicate(widths, 1, -1); // create the line mesh, i.e., the vertex indices

      indices = createMesh(numPoints, 0);
      pointBuffer({
        usage: "dynamic",
        type: "float",
        // 3 because its a 3-vector and 2 because each point is duplicated
        length: numPointsTotal * 3 * 2 * FLOAT_BYTES,
        data: pointsDup
      });
      widthBuffer({
        usage: "dynamic",
        type: "float",
        // 1 because its a scalar and 2 because each width is duplicated
        length: numPoints * 1 * 2 * FLOAT_BYTES,
        data: widthsDup
      });
      elements({
        primitive: "triangles",
        usage: "dynamic",
        type: "uint16",
        data: indices
      });
    };

    const clear = () => {
      destroy();
      init();
    };

    const destroy = () => {
      points = null;
      pointsPadded = null;
      pointsDup = null;
      widthsDup = null;
      indices = null;
      pointBuffer.destroy();
      widthBuffer.destroy();
      elements.destroy();
    };

    const draw = ({
      projection: newProjection,
      model: newModel,
      view: newView
    } = {}) => {
      // cache the view-defining matrices
      if (newProjection) {
        projection = newProjection;
      }

      if (newModel) {
        model = newModel;
      }

      if (newView) {
        view = newView;
      } // only draw when some points have been specified


      if (points && points.length > 1) {
        drawLine({
          projection,
          model,
          view
        });
      }
    };

    const getPoints = () => points;

    const setPoints = (newPoints = [], newWidths = widths, newIs2d = is2d) => {
      points = newPoints;
      is2d = newIs2d;
      dim = is2d ? 2 : 3;
      numPoints = Math.floor(points.length / dim);
      numPointsTotal = numPoints + 2;
      if (newWidths.length === numPoints) widths = newWidths;

      if (points && points.length > 1) {
        prepare();
      } else {
        clear();
      }
    };

    const getStyle = () => ({
      color,
      miter,
      width
    });

    const setStyle = ({
      color: newColor,
      miter: newMiter,
      width: newWidth
    } = {}) => {
      if (newColor) color = newColor;
      if (newMiter) miter = newMiter;
      if (+newWidth > 0) width = newWidth;
    };

    const getBuffer = () => ({
      points: pointBuffer,
      widths: widthBuffer
    });

    const getData = () => ({
      points: pointsDup,
      widths: widthsDup
    }); // initialize parameters


    init(); // prepare data if points are already specified

    if (points && points.length > 1) {
      setPoints(points);
    }

    return {
      clear,
      destroy,
      draw,
      getPoints,
      setPoints,
      getData,
      getBuffer,
      getStyle,
      setStyle
    };
  };

  const FRAGMENT_SHADER$1 = `
precision mediump float;

uniform sampler2D texture;

varying vec2 uv;

void main () {
  gl_FragColor = texture2D(texture, uv);
}
`;

  const VERTEX_SHADER$1 = `
precision mediump float;

uniform mat4 projection;
uniform mat4 model;
uniform mat4 view;

attribute vec2 position;

varying vec2 uv;

void main () {
  uv = position;
  gl_Position = projection * view * model * vec4(-1.0 + 2.0 * uv.x, 1.0 - 2.0 * uv.y, 0, 1);
}
`;

  const FRAGMENT_SHADER$2 = `
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif

precision mediump float;

varying vec4 color;

void main() {
  float r = 0.0, delta = 0.0, alpha = 1.0;
  vec2 cxy = 2.0 * gl_PointCoord - 1.0;
  r = dot(cxy, cxy);

  #ifdef GL_OES_standard_derivatives
    delta = fwidth(r);
    alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
  #endif

  gl_FragColor = vec4(color.rgb, alpha * color.a);
}
`;

  const VERTEX_SHADER$2 = `
precision highp float;

uniform sampler2D colorTex;
uniform float colorTexRes;
uniform sampler2D stateTex;
uniform float stateTexRes;
uniform float devicePixelRatio;
uniform sampler2D pointSizeTex;
uniform float pointSizeTexRes;
uniform float pointSizeExtra;
uniform float numPoints;
uniform float globalState;
uniform float isColoredByCategory;
uniform float isColoredByValue;
uniform float isSizedByCategory;
uniform float isSizedByValue;
uniform float maxColorTexIdx;
uniform float numColorStates;
uniform float maxPointSizeTexIdx;
uniform float scaling;
uniform mat4 projection;
uniform mat4 model;
uniform mat4 view;

attribute float stateIndex;

// variables to send to the fragment shader
varying vec4 color;

void main() {
  // First get the state
  float eps = 0.5 / stateTexRes;
  float stateRowIndex = floor((stateIndex + eps) / stateTexRes);
  vec2 stateTexIndex = vec2(
    (stateIndex / stateTexRes) - stateRowIndex + eps,
    stateRowIndex / stateTexRes + eps
  );

  vec4 state = texture2D(stateTex, stateTexIndex);

  gl_Position = projection * view * model * vec4(state.x, state.y, 0.0, 1.0);

  // Determine color index
  float colorIndexCat = state.z * isColoredByCategory;
  float colorIndexVal = floor(state.w * maxColorTexIdx) * isColoredByValue;
  float colorIndex = colorIndexCat + colorIndexVal;
  // Multiply by the number of color states per color
  // I.e., normal, active, hover, background, etc.
  colorIndex *= numColorStates;
  // Half a "pixel" or "texel" in texture coordinates
  eps = 0.5 / colorTexRes;
  float colorLinearIndex = colorIndex + globalState;
  // Need to add cEps here to avoid floating point issue that can lead to
  // dramatic changes in which color is loaded as floor(3/2.9999) = 1 but
  // floor(3/3.0001) = 0!
  float colorRowIndex = floor((colorLinearIndex + eps) / colorTexRes);

  vec2 colorTexIndex = vec2(
    (colorLinearIndex / colorTexRes) - colorRowIndex + eps,
    colorRowIndex / colorTexRes + eps
  );

  color = texture2D(colorTex, colorTexIndex);

  // The final scaling consists of linear scaling in [0, 1] and log scaling
  // in [1, [
  float finalScaling = min(1.0, scaling) + log2(max(1.0, scaling));

  // Determine point size
  float pointSizeIndexCat = state.z * isSizedByCategory;
  float pointSizeIndexVal = floor(state.w * maxPointSizeTexIdx) * isSizedByValue;
  float pointSizeIndex = pointSizeIndexCat + pointSizeIndexVal;

  eps = 0.5 / pointSizeTexRes;
  float pointSizeRowIndex = floor((pointSizeIndex + eps) / pointSizeTexRes);
  vec2 pointSizeTexIndex = vec2(
    (pointSizeIndex / pointSizeTexRes) - pointSizeRowIndex + eps,
    pointSizeRowIndex / pointSizeTexRes + eps
  );
  float pointSize = texture2D(pointSizeTex, pointSizeTexIndex).x;

  gl_PointSize = pointSize * finalScaling + pointSizeExtra * devicePixelRatio;
}
`;

  const SHADER = `precision mediump float;

uniform sampler2D startStateTex;
uniform sampler2D endStateTex;
uniform float t;

varying vec2 particleTextureIndex;

void main() {
  // Interpolate x, y, and value
  vec3 start = texture2D(startStateTex, particleTextureIndex).xyw;
  vec3 end = texture2D(endStateTex, particleTextureIndex).xyw;
  vec3 curr = start * (1.0 - t) + end * t;

  // The category cannot be interpolated
  float endCategory = texture2D(endStateTex, particleTextureIndex).z;

  gl_FragColor = vec4(curr.xy, endCategory, curr.z);
}`;

  const SHADER$1 = `precision mediump float;

attribute vec2 position;
varying vec2 particleTextureIndex;

void main() {
  // map normalized device coords to texture coords
  particleTextureIndex = 0.5 * (1.0 + position);

  gl_Position = vec4(position, 0, 1);
}`;

  // @flekschas/utils v0.25.0 Copyright 2020 Fritz Lekschas

  /* eslint no-param-reassign:0 */

  /**
   * Cubic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */
  const cubicIn = t => t * t * t;
  /**
   * Cubic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */


  const cubicInOut = t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  /**
   * Cubic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */


  const cubicOut = t => --t * t * t + 1;
  /**
   * Linear easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} Same as the input
   */


  const linear = t => t;
  /**
   * Quadratic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */


  const quadIn = t => t * t;
  /**
   * Quadratic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */


  const quadInOut = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  /**
   * Quadratic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */


  const quadOut = t => t * (2 - t);

  var COLOR_ACTIVE_IDX = 1;
  var COLOR_BG_IDX = 3;
  var COLOR_HOVER_IDX = 2;
  var COLOR_NORMAL_IDX = 0;
  var COLOR_NUM_STATES = 4;
  var FLOAT_BYTES$1 = Float32Array.BYTES_PER_ELEMENT;
  var GL_EXTENSIONS = ['OES_standard_derivatives', 'OES_texture_float']; // Easing

  var EASING_FNS = {
    cubicIn: cubicIn,
    cubicInOut: cubicInOut,
    cubicOut: cubicOut,
    linear: linear,
    quadIn: quadIn,
    quadInOut: quadInOut,
    quadOut: quadOut
  };
  var DEFAULT_EASING = cubicInOut; // Default lasso

  var LASSO_CLEAR_ON_DESELECT = 'deselect';
  var LASSO_CLEAR_ON_END = 'lassoEnd';
  var LASSO_CLEAR_EVENTS = [LASSO_CLEAR_ON_DESELECT, LASSO_CLEAR_ON_END];
  var DEFAULT_LASSO_MIN_DELAY = 10;
  var DEFAULT_LASSO_MIN_DIST = 3;
  var DEFAULT_LASSO_CLEAR_EVENT = LASSO_CLEAR_ON_END; // Default attribute

  var DEFAULT_DATA_ASPECT_RATIO = 1;
  var DEFAULT_WIDTH = 100;
  var DEFAULT_HEIGHT = 100; // Default styles

  var DEFAULT_POINT_SIZE = [6];
  var DEFAULT_POINT_SIZE_SELECTED = 2;
  var DEFAULT_POINT_OUTLINE_WIDTH = 2;
  var DEFAULT_SIZE_BY = null; // Default colors
  var DEFAULT_COLOR_BY = null;
  var DEFAULT_COLOR_NORMAL = [0.66, 0.66, 0.66, 1];
  var DEFAULT_COLOR_ACTIVE = [0, 0.55, 1, 1];
  var DEFAULT_COLOR_HOVER = [1, 1, 1, 1];
  var DEFAULT_COLOR_BG = [0, 0, 0, 1]; // Default view

  var DEFAULT_TARGET = [0, 0];
  var DEFAULT_DISTANCE = 1;
  var DEFAULT_ROTATION = 0; // prettier-ignore

  var DEFAULT_VIEW = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]); // Default misc

  var DEFAULT_BACKGROUND_IMAGE = null;
  var DEFAULT_LASSO_COLOR = [0, 0.666666667, 1, 1];
  var DEFAULT_SHOW_RECTICLE = false;
  var DEFAULT_RECTICLE_COLOR = [1, 1, 1, 0.5];
  var DEFAULT_DESELECT_ON_DBL_CLICK = true;
  var DEFAULT_DESELECT_ON_ESCAPE = true;

  /**
   * Get the max value of an array. helper method to be used with `Array.reduce()`.
   * @param   {number}  max  Accumulator holding the max value.
   * @param   {number}  x  Current value.
   * @return  {number}  Max value.
   */

  var arrayMax = function arrayMax(max, x) {
    return max > x ? max : x;
  };
  /**
   * Check if all GL extensions are enabled and warn otherwise
   * @param   {function}  regl  Regl instance to be tested
   * @return  {function}  Returns the Regl instance itself
   */

  var checkReglExtensions = function checkReglExtensions(regl) {
    if (!regl) return false;
    return GL_EXTENSIONS.reduce(function (every, EXTENSION) {
      if (!regl.hasExtension(EXTENSION)) {
        console.warn("WebGL: ".concat(EXTENSION, " extension not supported. Scatterplot might not render properly"));
        return false;
      }

      return every;
    }, true);
  };
  /**
   * Create a new Regl instance with `GL_EXTENSIONS` enables
   * @param   {object}  canvas  Canvas element to be rendered on
   * @return  {function}  New Regl instance
   */

  var createRegl = function createRegl(canvas) {
    var gl = canvas.getContext('webgl');
    var extensions = []; // Needed to run the tests properly as the headless-gl doesn't support all
    // extensions, which is fine for the functional tests.

    GL_EXTENSIONS.forEach(function (EXTENSION) {
      if (gl.getExtension(EXTENSION)) {
        extensions.push(EXTENSION);
      } else {
        console.warn("WebGL: ".concat(EXTENSION, " extension not supported. Scatterplot might not render properly"));
      }
    });
    return createOriginalRegl({
      gl: gl,
      extensions: extensions
    });
  };
  /**
   * L2 distance between a pair of 2D points
   * @param   {number}  x1  X coordinate of the first point
   * @param   {number}  y1  Y coordinate of the first point
   * @param   {number}  x2  X coordinate of the second point
   * @param   {number}  y2  Y coordinate of the first point
   * @return  {number}  L2 distance
   */

  var dist = function dist(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  };
  /**
   * Get the bounding box of a set of 2D positions
   * @param   {array}  positions2d  2D positions to be checked
   * @return  {array}  Quadruple of form `[xMin, yMin, xMax, yMax]` defining the
   *  bounding box
   */

  var getBBox = function getBBox(positions2d) {
    var xMin = Infinity;
    var xMax = -Infinity;
    var yMin = Infinity;
    var yMax = -Infinity;

    for (var i = 0; i < positions2d.length; i += 2) {
      xMin = positions2d[i] < xMin ? positions2d[i] : xMin;
      xMax = positions2d[i] > xMax ? positions2d[i] : xMax;
      yMin = positions2d[i + 1] < yMin ? positions2d[i + 1] : yMin;
      yMax = positions2d[i + 1] > yMax ? positions2d[i + 1] : yMax;
    }

    return [xMin, yMin, xMax, yMax];
  };
  /**
   * Convert a HEX-encoded color to an RGB-encoded color
   * @param   {string}  hex  HEX-encoded color string.
   * @param   {boolean}  isNormalize  If `true` the returned RGB values will be
   *   normalized to `[0,1]`.
   * @return  {array}  Triple holding the RGB values.
   */

  var hexToRgb = function hexToRgb(hex) {
    var isNormalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
      return "#".concat(r).concat(r).concat(g).concat(g).concat(b).concat(b);
    }).substring(1).match(/.{2}/g).map(function (x) {
      return parseInt(x, 16) / Math.pow(255, isNormalize);
    });
  };
  var isConditionalArray = function isConditionalArray(a, condition) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$minLength = _ref.minLength,
        minLength = _ref$minLength === void 0 ? 0 : _ref$minLength;

    return Array.isArray(a) && a.length >= minLength && a.every(condition);
  };
  var isPositiveNumber = function isPositiveNumber(x) {
    return !Number.isNaN(+x) && +x > 0;
  };
  /**
   * Create a function to limit choices to a predefined list
   * @param   {array}  choices  Array of acceptable choices
   * @param   {*}  defaultOption  Default choice
   * @return  {function}  Function limiting the choices
   */

  var limit = function limit(choices, defaultChoice) {
    return function (choice) {
      return choices.indexOf(choice) >= 0 ? choice : defaultChoice;
    };
  };
  /**
   * Promised-based image loading
   * @param   {string}  src  Remote image source, i.e., a URL
   * @return  {object}  Promise resolving to the image once its loaded
   */

  var loadImage = function loadImage(src) {
    var isCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return new Promise(function (accept, reject) {
      var image = new Image();
      if (isCrossOrigin) image.crossOrigin = 'anonymous';
      image.src = src;

      image.onload = function () {
        accept(image);
      };

      image.onerror = function (error) {
        reject(error);
      };
    });
  };
  /**
   * Create a Regl texture from an URL.
   * @param   {function}  regl  Regl instance used for creating the texture.
   * @param   {string}  url  Source URL of the image.
   * @param   {boolean}  isCrossOrigin  If `true` allow loading image from a
   *   source of another origin.
   * @return  {object}  Promise resolving to the texture object.
   */

  var createTextureFromUrl = function createTextureFromUrl(regl, url) {
    return new Promise(function (resolve, reject) {
      loadImage(url, url.indexOf(window.location.origin) !== 0 && url.indexOf('base64') === -1).then(function (image) {
        resolve(regl.texture(image));
      })["catch"](function (error) {
        reject(error);
      });
    });
  };
  /**
   * Convert a HEX-encoded color to an RGBA-encoded color
   * @param   {string}  hex  HEX-encoded color string.
   * @param   {boolean}  isNormalize  If `true` the returned RGBA values will be
   *   normalized to `[0,1]`.
   * @return  {array}  Triple holding the RGBA values.
   */

  var hexToRgba = function hexToRgba(hex) {
    var isNormalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return [].concat(_toConsumableArray(hexToRgb(hex, isNormalize)), [Math.pow(255, !isNormalize)]);
  };
  /**
   * Tests if a string is a valid HEX color encoding
   * @param   {string}  hex  HEX-encoded color string.
   * @return  {boolean}  If `true` the string is a valid HEX color encoding.
   */

  var isHex = function isHex(hex) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  };
  /**
   * Tests if a number is in `[0,1]`.
   * @param   {number}  x  Number to be tested.
   * @return  {boolean}  If `true` the number is in `[0,1]`.
   */

  var isNormFloat = function isNormFloat(x) {
    return x >= 0 && x <= 1;
  };
  /**
   * Tests if an array consist of normalized numbers that are in `[0,1]` only.
   * @param   {array}  a  Array to be tested
   * @return  {boolean}  If `true` the array contains only numbers in `[0,1]`.
   */

  var isNormFloatArray = function isNormFloatArray(a) {
    return Array.isArray(a) && a.every(isNormFloat);
  };
  /**
   * From: https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
   * @param   {Array}  point  Tuple of the form `[x,y]` to be tested.
   * @param   {Array}  polygon  1D list of vertices defining the polygon.
   * @return  {boolean}  If `true` point lies within the polygon.
   */

  var isPointInPolygon = function isPointInPolygon() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],
        _ref3 = _slicedToArray(_ref2, 2),
        px = _ref3[0],
        py = _ref3[1];

    var polygon = arguments.length > 1 ? arguments[1] : undefined;
    var x1;
    var y1;
    var x2;
    var y2;
    var isWithin = false;

    for (var i = 0, j = polygon.length - 2; i < polygon.length; i += 2) {
      x1 = polygon[i];
      y1 = polygon[i + 1];
      x2 = polygon[j];
      y2 = polygon[j + 1];
      if (y1 > py !== y2 > py && px < (x2 - x1) * (py - y1) / (y2 - y1) + x1) isWithin = !isWithin;
      j = i;
    }

    return isWithin;
  };
  /**
   * Tests if a variable is a string
   * @param   {*}  s  Variable to be tested
   * @return  {boolean}  If `true` variable is a string
   */

  var isString = function isString(s) {
    return typeof s === 'string' || s instanceof String;
  };
  /**
   * Tests if a number is an interger and in `[0,255]`.
   * @param   {number}  x  Number to be tested.
   * @return  {boolean}  If `true` the number is an interger and in `[0,255]`.
   */

  var isUint8 = function isUint8(x) {
    return Number.isInteger(x) && x >= 0 && x <= 255;
  };
  /**
   * Tests if an array consist of Uint8 numbers only.
   * @param   {array}  a  Array to be tested.
   * @return  {boolean}  If `true` the array contains only Uint8 numbers.
   */

  var isUint8Array = function isUint8Array(a) {
    return Array.isArray(a) && a.every(isUint8);
  };
  /**
   * Tests if an array is encoding an RGB color.
   * @param   {array}  rgb  Array to be tested
   * @return  {boolean}  If `true` the array hold a triple of Uint8 numbers or
   *   a triple of normalized floats.
   */

  var isRgb = function isRgb(rgb) {
    return rgb.length === 3 && (isNormFloatArray(rgb) || isUint8Array(rgb));
  };
  /**
   * Tests if an array is encoding an RGBA color.
   * @param   {array}  rgb  Array to be tested
   * @return  {boolean}  If `true` the array hold a quadruple of Uint8 numbers or
   *   a quadruple of normalized floats.
   */

  var isRgba = function isRgba(rgba) {
    return rgba.length === 4 && (isNormFloatArray(rgba) || isUint8Array(rgba));
  };
  /**
   * Test if a color is multiple colors
   * @param   {*}  color  To be tested
   * @return  {boolean}  If `true`, `color` is an array of colors.
   */

  var isMultipleColors = function isMultipleColors(color) {
    return Array.isArray(color) && color.length && (Array.isArray(color[0]) || isString(color[0]));
  };
  /**
   * Fast version of `Math.max`. Based on
   *   https://jsperf.com/math-min-max-vs-ternary-vs-if/24 `Math.max` is not
   *   very fast
   * @param   {number}  a  Value A
   * @param   {number}  b  Value B
   * @return  {boolean}  If `true` A is greater than B.
   */

  var max = function max(a, b) {
    return a > b ? a : b;
  };
  /**
   * Fast version of `Math.min`. Based on
   *   https://jsperf.com/math-min-max-vs-ternary-vs-if/24 `Math.max` is not
   *   very fast
   * @param   {number}  a  Value A
   * @param   {number}  b  Value B
   * @return  {boolean}  If `true` A is smaller than B.
   */

  var min = function min(a, b) {
    return a < b ? a : b;
  };
  /**
   * Normalize an array
   * @param   {array}  a  Array to be normalized.
   * @return  {array}  Normalized array.
   */

  var normNumArray = function normNumArray(a) {
    return a.map(function (x) {
      return x / a.reduce(arrayMax, -Infinity);
    });
  };
  /**
   * Convert a color to an RGBA color
   * @param   {*}  color  Color to be converted. Currently supports:
   *   HEX, RGB, or RGBA.
   * @param   {boolean}  isNormalize  If `true` the returned RGBA values will be
   *   normalized to `[0,1]`.
   * @return  {array}  Quadruple defining an RGBA color.
   */

  var toRgba = function toRgba(color, isNormalize) {
    if (isRgba(color)) return isNormalize && !isNormFloatArray(color) ? normNumArray(color) : color;
    if (isRgb(color)) return [].concat(_toConsumableArray(isNormalize ? normNumArray(color) : color), [Math.pow(255, !isNormalize)]);
    if (isHex(color)) return hexToRgba(color, isNormalize);
    console.warn('Only HEX, RGB, and RGBA are handled by this function. Returning white instead.');
    return isNormalize ? [1, 1, 1, 1] : [255, 255, 255, 255];
  };

  var version = "0.14.0";

  var deprecations = {
    background: 'backgroundColor',
    target: 'cameraTarget',
    distance: 'cameraDistance',
    rotation: 'cameraRotation',
    view: 'cameraView'
  };

  var checkDeprecations = function checkDeprecations(properties) {
    Object.keys(properties).filter(function (prop) {
      return deprecations[prop];
    }).forEach(function (name) {
      console.warn("regl-scatterplot: the \"".concat(name, "\" property is deprecated. Please use \"").concat(deprecations[name], "\" instead."));
    });
  };

  var createScatterplot = function createScatterplot() {
    var initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var pubSub = createPubSub({
      async: !initialProperties.syncEvents,
      caseInsensitive: true
    });
    var scratch = new Float32Array(16);
    var mousePosition = [0, 0];
    checkDeprecations(initialProperties);
    var initialRegl = initialProperties.regl,
        initialBackground = initialProperties.background,
        initialBackgroundColor = initialProperties.backgroundColor,
        _initialProperties$ba = initialProperties.backgroundImage,
        initialBackgroundImage = _initialProperties$ba === void 0 ? DEFAULT_BACKGROUND_IMAGE : _initialProperties$ba,
        initialCameraTarget = initialProperties.cameraTarget,
        initialCameraDistance = initialProperties.cameraDistance,
        initialCameraRotation = initialProperties.cameraRotation,
        initialCameraView = initialProperties.cameraView,
        _initialProperties$ca = initialProperties.canvas,
        initialCanvas = _initialProperties$ca === void 0 ? document.createElement('canvas') : _initialProperties$ca,
        _initialProperties$co = initialProperties.colorBy,
        initialColorBy = _initialProperties$co === void 0 ? DEFAULT_COLOR_BY : _initialProperties$co,
        _initialProperties$de = initialProperties.deselectOnDblClick,
        initialDeselectOnDblClick = _initialProperties$de === void 0 ? DEFAULT_DESELECT_ON_DBL_CLICK : _initialProperties$de,
        _initialProperties$de2 = initialProperties.deselectOnEscape,
        initialDeselectOnEscape = _initialProperties$de2 === void 0 ? DEFAULT_DESELECT_ON_ESCAPE : _initialProperties$de2,
        _initialProperties$la = initialProperties.lassoColor,
        initialLassoColor = _initialProperties$la === void 0 ? DEFAULT_LASSO_COLOR : _initialProperties$la,
        _initialProperties$la2 = initialProperties.lassoMinDelay,
        initialLassoMinDelay = _initialProperties$la2 === void 0 ? DEFAULT_LASSO_MIN_DELAY : _initialProperties$la2,
        _initialProperties$la3 = initialProperties.lassoMinDist,
        initialLassoMinDist = _initialProperties$la3 === void 0 ? DEFAULT_LASSO_MIN_DIST : _initialProperties$la3,
        _initialProperties$la4 = initialProperties.lassoClearEvent,
        initialLassoClearEvent = _initialProperties$la4 === void 0 ? DEFAULT_LASSO_CLEAR_EVENT : _initialProperties$la4,
        _initialProperties$sh = initialProperties.showRecticle,
        initialShowRecticle = _initialProperties$sh === void 0 ? DEFAULT_SHOW_RECTICLE : _initialProperties$sh,
        _initialProperties$re = initialProperties.recticleColor,
        initialRecticleColor = _initialProperties$re === void 0 ? DEFAULT_RECTICLE_COLOR : _initialProperties$re,
        _initialProperties$po = initialProperties.pointColor,
        initialPointColor = _initialProperties$po === void 0 ? DEFAULT_COLOR_NORMAL : _initialProperties$po,
        _initialProperties$po2 = initialProperties.pointColorActive,
        initialPointColorActive = _initialProperties$po2 === void 0 ? DEFAULT_COLOR_ACTIVE : _initialProperties$po2,
        _initialProperties$po3 = initialProperties.pointColorHover,
        initialPointColorHover = _initialProperties$po3 === void 0 ? DEFAULT_COLOR_HOVER : _initialProperties$po3,
        _initialProperties$po4 = initialProperties.pointSize,
        initialPointSize = _initialProperties$po4 === void 0 ? DEFAULT_POINT_SIZE : _initialProperties$po4,
        _initialProperties$po5 = initialProperties.pointSizeSelected,
        initialPointSizeSelected = _initialProperties$po5 === void 0 ? DEFAULT_POINT_SIZE_SELECTED : _initialProperties$po5,
        _initialProperties$po6 = initialProperties.pointOutlineWidth,
        initialPointOutlineWidth = _initialProperties$po6 === void 0 ? DEFAULT_POINT_OUTLINE_WIDTH : _initialProperties$po6,
        _initialProperties$si = initialProperties.sizeBy,
        initialSizeBy = _initialProperties$si === void 0 ? DEFAULT_SIZE_BY : _initialProperties$si,
        _initialProperties$wi = initialProperties.width,
        initialWidth = _initialProperties$wi === void 0 ? DEFAULT_WIDTH : _initialProperties$wi,
        _initialProperties$he = initialProperties.height,
        initialHeight = _initialProperties$he === void 0 ? DEFAULT_HEIGHT : _initialProperties$he,
        initialTarget = initialProperties.target,
        initialDistance = initialProperties.distance,
        initialRotation = initialProperties.rotation,
        initialView = initialProperties.view;
    checkReglExtensions(initialRegl);
    var backgroundColor = toRgba(initialBackgroundColor || initialBackground || DEFAULT_COLOR_BG, true);
    var backgroundImage = null;
    var canvas = initialCanvas;
    var width = initialWidth;
    var height = initialHeight;
    var pointSize = isConditionalArray(initialPointSize, isPositiveNumber, {
      minLength: 1
    }) ? _toConsumableArray(initialPointSize) : [initialPointSize];
    var pointSizeSelected = initialPointSizeSelected;
    var pointOutlineWidth = initialPointOutlineWidth;
    var regl = initialRegl || createRegl(initialCanvas);
    var camera;
    var lasso;
    var mouseDown = false;
    var mouseDownShift = false;
    var mouseDownPosition = [0, 0];
    var numPoints = 0;
    var selection = [];
    var lassoColor = toRgba(initialLassoColor, true);
    var lassoMinDelay = +initialLassoMinDelay;
    var lassoMinDist = +initialLassoMinDist;
    var lassoClearEvent = initialLassoClearEvent;
    var lassoPos = [];
    var lassoPoints = [];
    var lassoPrevMousePos;
    var searchIndex;
    var viewAspectRatio;
    var dataAspectRatio = DEFAULT_DATA_ASPECT_RATIO;
    var projection;
    var model;
    var showRecticle = initialShowRecticle;
    var recticleHLine;
    var recticleVLine;
    var recticleColor = toRgba(initialRecticleColor, true);
    var deselectOnDblClick = initialDeselectOnDblClick;
    var deselectOnEscape = initialDeselectOnEscape;
    var pointColors = isMultipleColors(initialPointColor) ? _toConsumableArray(initialPointColor) : [initialPointColor];
    var pointColorsActive = isMultipleColors(initialPointColorActive) ? _toConsumableArray(initialPointColorActive) : [initialPointColorActive];
    var pointColorsHover = isMultipleColors(initialPointColorHover) ? _toConsumableArray(initialPointColorHover) : [initialPointColorHover];
    pointColors = pointColors.map(function (color) {
      return toRgba(color, true);
    });
    pointColorsActive = pointColorsActive.map(function (color) {
      return toRgba(color, true);
    });
    pointColorsHover = pointColorsHover.map(function (color) {
      return toRgba(color, true);
    });
    var stateTex; // Stores the point texture holding x, y, category, and value

    var prevStateTex; // Stores the previous point texture. Used for transitions

    var tmpStateTex; // Stores a temporary point texture. Used for transitions

    var tmpStateBuffer; // Temporary frame buffer

    var stateTexRes = 0; // Width and height of the texture

    var normalPointsIndexBuffer; // Buffer holding the indices pointing to the correct texel

    var selectedPointsIndexBuffer; // Used for pointing to the selected texels

    var hoveredPointIndexBuffer; // Used for pointing to the hovered texels

    var isTransitioning = false;
    var transitionStartTime = null;
    var transitionRafId = null;
    var preTransitionShowRecticle = showRecticle;
    var colorTex; // Stores the point color texture

    var colorTexRes = 0; // Width and height of the texture

    var pointSizeTex; // Stores the point sizes

    var pointSizeTexRes = 0; // Width and height of the texture

    var colorBy = initialColorBy;
    var sizeBy = initialSizeBy;
    var isViewChanged = false;
    var isInit = false;
    var opacity = 1;
    var hoveredPoint;
    var isMouseInCanvas = false;
    var xScale = initialProperties.xScale || null;
    var yScale = initialProperties.yScale || null;
    var xDomainStart = 0;
    var xDomainSize = 0;
    var yDomainStart = 0;
    var yDomainSize = 0;

    if (xScale) {
      xDomainStart = xScale.domain()[0];
      xDomainSize = xScale.domain()[1] - xScale.domain()[0];
      xScale.range([0, width]);
    }

    if (yScale) {
      yDomainStart = yScale.domain()[0];
      yDomainSize = yScale.domain()[1] - yScale.domain()[0];
      yScale.range([height, 0]);
    } // Get a copy of the current mouse position


    var getMousePos = function getMousePos() {
      return mousePosition.slice();
    };

    var getNdcX = function getNdcX(x) {
      return -1 + x / width * 2;
    };

    var getNdcY = function getNdcY(y) {
      return 1 + y / height * -2;
    }; // Get relative WebGL position


    var getMouseGlPos = function getMouseGlPos() {
      return [getNdcX(mousePosition[0]), getNdcY(mousePosition[1])];
    };

    var getScatterGlPos = function getScatterGlPos(xGl, yGl) {
      // Homogeneous vector
      var v = [xGl, yGl, 1, 1]; // projection^-1 * view^-1 * model^-1 is the same as
      // model * view^-1 * projection

      var mvp = invert(scratch, multiply(scratch, projection, multiply(scratch, camera.view, model))); // Translate vector

      transformMat4(v, v, mvp);
      return v.slice(0, 2);
    };

    var raycast = function raycast() {
      var _getMouseGlPos = getMouseGlPos(),
          _getMouseGlPos2 = _slicedToArray(_getMouseGlPos, 2),
          xGl = _getMouseGlPos2[0],
          yGl = _getMouseGlPos2[1];

      var _getScatterGlPos = getScatterGlPos(xGl, yGl),
          _getScatterGlPos2 = _slicedToArray(_getScatterGlPos, 2),
          x = _getScatterGlPos2[0],
          y = _getScatterGlPos2[1];

      var scaling = camera.scaling;
      var scaledPointSize = 2 * pointSize * (min(1.0, scaling) + Math.log2(max(1.0, scaling))) * window.devicePixelRatio;
      var xNormalizedScaledPointSize = scaledPointSize / width;
      var yNormalizedScaledPointSize = scaledPointSize / height; // Get all points within a close range

      var pointsInBBox = searchIndex.range(x - xNormalizedScaledPointSize, y - yNormalizedScaledPointSize, x + xNormalizedScaledPointSize, y + yNormalizedScaledPointSize); // Find the closest point

      var minDist = scaledPointSize;
      var clostestPoint;
      pointsInBBox.forEach(function (idx) {
        var _searchIndex$points$i = _slicedToArray(searchIndex.points[idx], 2),
            ptX = _searchIndex$points$i[0],
            ptY = _searchIndex$points$i[1];

        var d = dist(ptX, ptY, x, y);

        if (d < minDist) {
          minDist = d;
          clostestPoint = idx;
        }
      });
      if (minDist < pointSize / width * 2) return clostestPoint;
      return -1;
    };

    var lassoExtend = function lassoExtend() {
      var currMousePos = getMousePos();

      var _getMouseGlPos3 = getMouseGlPos(),
          _getMouseGlPos4 = _slicedToArray(_getMouseGlPos3, 2),
          xGl = _getMouseGlPos4[0],
          yGl = _getMouseGlPos4[1];

      if (!lassoPrevMousePos) {
        var point = getScatterGlPos(xGl, yGl);
        lassoPos = _toConsumableArray(point);
        lassoPoints = [point];
        lassoPrevMousePos = currMousePos;
      } else {
        var d = dist.apply(void 0, _toConsumableArray(currMousePos).concat(_toConsumableArray(lassoPrevMousePos)));

        if (d > lassoMinDist) {
          var _lassoPos;

          var _point = getScatterGlPos(xGl, yGl);

          (_lassoPos = lassoPos).push.apply(_lassoPos, _toConsumableArray(_point));

          lassoPoints.push(_point);
          lassoPrevMousePos = currMousePos;

          if (lassoPos.length > 2) {
            lasso.setPoints(lassoPos);
          }
        }
      }

      pubSub.publish('lassoExtend', {
        coordinates: lassoPoints
      });
    };

    var lassoExtendDb = throttle(lassoExtend, lassoMinDelay);

    var findPointsInLasso = function findPointsInLasso(lassoPolygon) {
      var _searchIndex;

      // get the bounding box of the lasso selection...
      var bBox = getBBox(lassoPolygon); // ...to efficiently preselect potentially selected points

      var pointsInBBox = (_searchIndex = searchIndex).range.apply(_searchIndex, _toConsumableArray(bBox)); // next we test each point in the bounding box if it is in the polygon too


      var pointsInPolygon = [];
      pointsInBBox.forEach(function (pointIdx) {
        if (isPointInPolygon(searchIndex.points[pointIdx], lassoPolygon)) pointsInPolygon.push(pointIdx);
      });
      return pointsInPolygon;
    };

    var lassoClear = function lassoClear() {
      lassoPos = [];
      lassoPoints = [];
      if (lasso) lasso.clear();
    };

    var deselect = function deselect() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$preventEvent = _ref.preventEvent,
          preventEvent = _ref$preventEvent === void 0 ? false : _ref$preventEvent;

      if (lassoClearEvent === LASSO_CLEAR_ON_DESELECT) lassoClear();

      if (selection.length) {
        if (!preventEvent) pubSub.publish('deselect');
        selection = [];
        drawRaf(); // eslint-disable-line no-use-before-define
      }
    };

    var select = function select(points) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$preventEvent = _ref2.preventEvent,
          preventEvent = _ref2$preventEvent === void 0 ? false : _ref2$preventEvent;

      selection = points;
      selectedPointsIndexBuffer({
        usage: 'dynamic',
        type: 'float',
        data: new Float32Array(selection)
      });
      if (!preventEvent) pubSub.publish('select', {
        points: selection
      });
      drawRaf(); // eslint-disable-line no-use-before-define
    };

    var getRelativeMousePosition = function getRelativeMousePosition(event) {
      var rect = canvas.getBoundingClientRect();
      mousePosition[0] = event.clientX - rect.left;
      mousePosition[1] = event.clientY - rect.top;
      return [].concat(mousePosition);
    };

    var lassoStart = function lassoStart() {
      // Fix camera for the lasso selection
      camera.config({
        isFixed: true
      }); // Make sure we start a new lasso selection

      lassoPrevMousePos = undefined;
      lassoClear();
      pubSub.publish('lassoStart');
    };

    var lassoEnd = function lassoEnd() {
      camera.config({
        isFixed: false
      }); // const t0 = performance.now();

      var pointsInLasso = findPointsInLasso(lassoPos); // console.log(`found ${pointsInLasso.length} in ${performance.now() - t0} msec`);

      select(pointsInLasso);
      lassoPrevMousePos = undefined;
      pubSub.publish('lassoEnd', {
        coordinates: lassoPoints
      });
      if (lassoClearEvent === LASSO_CLEAR_ON_END) lassoClear();
    };

    var mouseDownHandler = function mouseDownHandler(event) {
      if (!isInit) return;
      mouseDown = true;
      mouseDownPosition = getRelativeMousePosition(event);
      mouseDownShift = event.shiftKey;
      if (mouseDownShift) lassoStart();
    };

    var mouseUpHandler = function mouseUpHandler() {
      if (!isInit) return;
      mouseDown = false;

      if (mouseDownShift) {
        mouseDownShift = false;
        lassoEnd();
      }
    };

    var mouseClickHandler = function mouseClickHandler(event) {
      if (!isInit) return;
      var currentMousePosition = getRelativeMousePosition(event);
      var clickDist = dist.apply(void 0, _toConsumableArray(currentMousePosition).concat(_toConsumableArray(mouseDownPosition)));
      if (clickDist >= lassoMinDist) return;
      var clostestPoint = raycast();
      if (clostestPoint >= 0) select([clostestPoint]);
    };

    var mouseDblClickHandler = function mouseDblClickHandler() {
      if (deselectOnDblClick) deselect();
    };

    var mouseMoveHandler = function mouseMoveHandler(event) {
      if (!isInit || !isMouseInCanvas && !mouseDown) return;
      getRelativeMousePosition(event); // Only ray cast if the mouse cursor is inside

      if (isMouseInCanvas && !mouseDownShift) {
        var clostestPoint = raycast();
        hover(clostestPoint); // eslint-disable-line no-use-before-define
      }

      if (mouseDownShift) lassoExtendDb(); // Always redraw when mousedown as the user might have panned or lassoed

      if (mouseDown) drawRaf(); // eslint-disable-line no-use-before-define
    };

    var blurHandler = function blurHandler() {
      if (!isInit) return;
      hoveredPoint = undefined;
      isMouseInCanvas = false;
      mouseUpHandler();
      drawRaf(); // eslint-disable-line no-use-before-define
    };

    var createPointSizeTexture = function createPointSizeTexture() {
      var numPointSizes = pointSize.length;
      pointSizeTexRes = Math.max(2, Math.ceil(Math.sqrt(numPointSizes)));
      var rgba = new Float32Array(Math.pow(pointSizeTexRes, 2) * 4);
      pointSize.forEach(function (size, i) {
        rgba[i * 4] = size;
      });
      return regl.texture({
        data: rgba,
        shape: [pointSizeTexRes, pointSizeTexRes, 4],
        type: 'float'
      });
    };

    var getColors = function getColors() {
      var n = pointColors.length;
      var n2 = pointColorsActive.length;
      var n3 = pointColorsHover.length;
      var colors = [];

      if (n === n2 && n2 === n3) {
        for (var i = 0; i < n; i++) {
          colors.push(pointColors[i], pointColorsActive[i], pointColorsHover[i], backgroundColor);
        }
      } else {
        for (var _i = 0; _i < n; _i++) {
          var rgbaOpaque = [pointColors[_i][0], pointColors[_i][1], pointColors[_i][2], 1];
          var colorActive = colorBy === DEFAULT_COLOR_BY ? pointColorsActive[0] : rgbaOpaque;
          var colorHover = colorBy === DEFAULT_COLOR_BY ? pointColorsHover[0] : rgbaOpaque;
          colors.push(pointColors[_i], colorActive, colorHover, backgroundColor);
        }
      }

      return colors;
    };

    var createColorTexture = function createColorTexture() {
      var colors = getColors();
      var numColors = colors.length;
      colorTexRes = Math.max(2, Math.ceil(Math.sqrt(numColors)));
      var rgba = new Float32Array(Math.pow(colorTexRes, 2) * 4);
      colors.forEach(function (color, i) {
        rgba[i * 4] = color[0]; // r

        rgba[i * 4 + 1] = color[1]; // g

        rgba[i * 4 + 2] = color[2]; // b
        // For all normal state colors check if the global opacity is not 1 and
        // if so use that instead.

        rgba[i * 4 + 3] = i % COLOR_NUM_STATES > 0 || opacity === 1 ? color[3] : opacity; // a
      });
      return regl.texture({
        data: rgba,
        shape: [colorTexRes, colorTexRes, 4],
        type: 'float'
      });
    };

    var updateViewAspectRatio = function updateViewAspectRatio() {
      viewAspectRatio = width / height;
      projection = fromScaling([], [1 / viewAspectRatio, 1, 1]);
      model = fromScaling([], [dataAspectRatio, 1, 1]);
    };

    var setDataAspectRatio = function setDataAspectRatio(newDataAspectRatio) {
      if (+newDataAspectRatio <= 0) return;
      dataAspectRatio = newDataAspectRatio;
    };

    var setColors = function setColors(getter, setter) {
      return function (newColors) {
        if (!newColors || !newColors.length) return;
        var colors = getter();

        var prevColors = _toConsumableArray(colors);

        var tmpColors = isMultipleColors(newColors) ? newColors : [newColors];
        tmpColors = tmpColors.map(function (color) {
          return toRgba(color, true);
        });
        if (colorTex) colorTex.destroy();

        try {
          setter(tmpColors);
          colorTex = createColorTexture();
        } catch (e) {
          console.error('Invalid colors. Switching back to default colors.'); // eslint-disable-next-line no-param-reassign

          setter(prevColors);
          colorTex = createColorTexture();
        }
      };
    };

    var setPointColors = setColors(function () {
      return pointColors;
    }, function (colors) {
      pointColors = colors;
    });
    var setPointColorsActive = setColors(function () {
      return pointColorsActive;
    }, function (colors) {
      pointColorsActive = colors;
    });
    var setPointColorsHover = setColors(function () {
      return pointColorsHover;
    }, function (colors) {
      pointColorsHover = colors;
    });

    var computeDomainView = function computeDomainView() {
      var xyStartPt = getScatterGlPos(-1, -1);
      var xyEndPt = getScatterGlPos(1, 1);
      var xStart = (xyStartPt[0] + 1) / 2;
      var xEnd = (xyEndPt[0] + 1) / 2;
      var yStart = (xyStartPt[1] + 1) / 2;
      var yEnd = (xyEndPt[1] + 1) / 2;
      var xDomainView = [xDomainStart + xStart * xDomainSize, xDomainStart + xEnd * xDomainSize];
      var yDomainView = [yDomainStart + yStart * yDomainSize, yDomainStart + yEnd * yDomainSize];
      return [xDomainView, yDomainView];
    };

    var updateScales = function updateScales() {
      if (!xScale && !yScale) return;

      var _computeDomainView = computeDomainView(),
          _computeDomainView2 = _slicedToArray(_computeDomainView, 2),
          xDomainView = _computeDomainView2[0],
          yDomainView = _computeDomainView2[1];

      if (xScale) xScale.domain(xDomainView);
      if (yScale) yScale.domain(yDomainView);
    };

    var setHeight = function setHeight(newHeight) {
      if (!+newHeight || +newHeight <= 0) return;
      height = +newHeight;
      canvas.height = height * window.devicePixelRatio;

      if (yScale) {
        yScale.range([height, 0]);
        updateScales();
      }
    };

    var setPointSize = function setPointSize(newPointSize) {
      if (isConditionalArray(newPointSize, isPositiveNumber, {
        minLength: 1
      })) pointSize = _toConsumableArray(newPointSize);
      if (isPositiveNumber(+newPointSize)) pointSize = [+newPointSize];
      pointSizeTex = createPointSizeTexture();
    };

    var setPointSizeSelected = function setPointSizeSelected(newPointSizeSelected) {
      if (!+newPointSizeSelected || +newPointSizeSelected < 0) return;
      pointSizeSelected = +newPointSizeSelected;
    };

    var setPointOutlineWidth = function setPointOutlineWidth(newPointOutlineWidth) {
      if (!+newPointOutlineWidth || +newPointOutlineWidth < 0) return;
      pointOutlineWidth = +newPointOutlineWidth;
    };

    var setWidth = function setWidth(newWidth) {
      if (!+newWidth || +newWidth <= 0) return;
      width = +newWidth;
      canvas.width = width * window.devicePixelRatio;

      if (xScale) {
        xScale.range([0, width]);
        updateScales();
      }
    };

    var setColorBy = function setColorBy(type) {
      switch (type) {
        case 'category':
          colorBy = 'category';
          break;

        case 'value':
          colorBy = 'value';
          break;

        default:
          colorBy = DEFAULT_COLOR_BY;
      }
    };

    var setOpacity = function setOpacity(newOpacity) {
      if (!+newOpacity || +newOpacity <= 0) return;
      opacity = +newOpacity;
      if (colorTex) colorTex.destroy();
      colorTex = createColorTexture();
    };

    var setSizeBy = function setSizeBy(type) {
      switch (type) {
        case 'category':
          sizeBy = 'category';
          break;

        case 'value':
          sizeBy = 'value';
          break;

        default:
          sizeBy = DEFAULT_SIZE_BY;
      }
    };

    var getBackgroundImage = function getBackgroundImage() {
      return backgroundImage;
    };

    var getColorTex = function getColorTex() {
      return colorTex;
    };

    var getColorTexRes = function getColorTexRes() {
      return colorTexRes;
    };

    var getDevicePixelRatio = function getDevicePixelRatio() {
      return window.devicePixelRatio;
    };

    var getNormalPointsIndexBuffer = function getNormalPointsIndexBuffer() {
      return normalPointsIndexBuffer;
    };

    var getSelectedPointsIndexBuffer = function getSelectedPointsIndexBuffer() {
      return selectedPointsIndexBuffer;
    };

    var getPointSizeTex = function getPointSizeTex() {
      return pointSizeTex;
    };

    var getPointSizeTexRes = function getPointSizeTexRes() {
      return pointSizeTexRes;
    };

    var getNormalPointSizeExtra = function getNormalPointSizeExtra() {
      return 0;
    };

    var getStateTex = function getStateTex() {
      return tmpStateTex || stateTex;
    };

    var getStateTexRes = function getStateTexRes() {
      return stateTexRes;
    };

    var getProjection = function getProjection() {
      return projection;
    };

    var getView = function getView() {
      return camera.view;
    };

    var getModel = function getModel() {
      return model;
    };

    var getScaling = function getScaling() {
      return camera.scaling;
    };

    var getNormalNumPoints = function getNormalNumPoints() {
      return numPoints;
    };

    var getIsColoredByCategory = function getIsColoredByCategory() {
      return (colorBy === 'category') * 1;
    };

    var getIsColoredByValue = function getIsColoredByValue() {
      return (colorBy === 'value') * 1;
    };

    var getIsSizedByCategory = function getIsSizedByCategory() {
      return (sizeBy === 'category') * 1;
    };

    var getIsSizedByValue = function getIsSizedByValue() {
      return (sizeBy === 'value') * 1;
    };

    var getMaxColorTexIdx = function getMaxColorTexIdx() {
      return pointColors.length - 1;
    };

    var getMaxPointSizeTexIdx = function getMaxPointSizeTexIdx() {
      return pointSize.length;
    };

    var updatePoints = regl({
      framebuffer: function framebuffer() {
        return tmpStateBuffer;
      },
      vert: SHADER$1,
      frag: SHADER,
      attributes: {
        position: [-4, 0, 4, 4, 4, -4]
      },
      uniforms: {
        startStateTex: function startStateTex() {
          return prevStateTex;
        },
        endStateTex: function endStateTex() {
          return stateTex;
        },
        t: function t(ctx, props) {
          return props.t;
        }
      },
      count: 3
    });

    var drawPoints = function drawPoints(getPointSizeExtra, getNumPoints, getStateIndexBuffer) {
      var globalState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COLOR_NORMAL_IDX;
      return regl({
        frag: FRAGMENT_SHADER$2,
        vert: VERTEX_SHADER$2,
        blend: {
          enable: true,
          func: {
            srcRGB: 'src alpha',
            srcAlpha: 'one',
            dstRGB: 'one minus src alpha',
            dstAlpha: 'one minus src alpha'
          }
        },
        depth: {
          enable: false
        },
        attributes: {
          stateIndex: {
            buffer: getStateIndexBuffer,
            size: 1
          }
        },
        uniforms: {
          projection: getProjection,
          model: getModel,
          view: getView,
          devicePixelRatio: getDevicePixelRatio,
          scaling: getScaling,
          pointSizeTex: getPointSizeTex,
          pointSizeTexRes: getPointSizeTexRes,
          pointSizeExtra: getPointSizeExtra,
          globalState: globalState,
          colorTex: getColorTex,
          colorTexRes: getColorTexRes,
          stateTex: getStateTex,
          stateTexRes: getStateTexRes,
          isColoredByCategory: getIsColoredByCategory,
          isColoredByValue: getIsColoredByValue,
          isSizedByCategory: getIsSizedByCategory,
          isSizedByValue: getIsSizedByValue,
          maxColorTexIdx: getMaxColorTexIdx,
          numColorStates: COLOR_NUM_STATES,
          maxPointSizeTexIdx: getMaxPointSizeTexIdx
        },
        count: getNumPoints,
        primitive: 'points'
      });
    };

    var drawPointBodies = drawPoints(getNormalPointSizeExtra, getNormalNumPoints, getNormalPointsIndexBuffer);
    var drawHoveredPoint = drawPoints(getNormalPointSizeExtra, function () {
      return 1;
    }, function () {
      return hoveredPointIndexBuffer;
    }, COLOR_HOVER_IDX);

    var drawSelectedPoint = function drawSelectedPoint() {
      var numOutlinedPoints = selection.length; // Draw outer outline

      drawPoints(function () {
        return (pointSizeSelected + pointOutlineWidth * 2) * window.devicePixelRatio;
      }, function () {
        return numOutlinedPoints;
      }, getSelectedPointsIndexBuffer, COLOR_ACTIVE_IDX)(); // Draw inner outline

      drawPoints(function () {
        return (pointSizeSelected + pointOutlineWidth) * window.devicePixelRatio;
      }, function () {
        return numOutlinedPoints;
      }, getSelectedPointsIndexBuffer, COLOR_BG_IDX)(); // Draw body

      drawPoints(function () {
        return pointSizeSelected;
      }, function () {
        return numOutlinedPoints;
      }, getSelectedPointsIndexBuffer, COLOR_ACTIVE_IDX)();
    };

    var drawBackgroundImage = regl({
      frag: FRAGMENT_SHADER$1,
      vert: VERTEX_SHADER$1,
      attributes: {
        position: [0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0]
      },
      uniforms: {
        projection: getProjection,
        model: getModel,
        view: getView,
        texture: getBackgroundImage
      },
      count: 6
    });
    var drawPolygon2d = regl({
      vert: "\n      precision mediump float;\n      uniform mat4 projection;\n      uniform mat4 model;\n      uniform mat4 view;\n      attribute vec2 position;\n      void main () {\n        gl_Position = projection * view * model * vec4(position, 0, 1);\n      }",
      frag: "\n      precision mediump float;\n      uniform vec4 color;\n      void main () {\n        gl_FragColor = vec4(color.rgb, 0.2);\n      }",
      depth: {
        enable: false
      },
      blend: {
        enable: true,
        func: {
          srcRGB: 'src alpha',
          srcAlpha: 'one',
          dstRGB: 'one minus src alpha',
          dstAlpha: 'one minus src alpha'
        }
      },
      attributes: {
        position: function position() {
          return lassoPoints;
        }
      },
      uniforms: {
        projection: getProjection,
        model: getModel,
        view: getView,
        color: function color() {
          return lassoColor;
        }
      },
      elements: function elements() {
        return Array(lassoPoints.length - 2).fill().map(function (_, i) {
          return [0, i + 1, i + 2];
        });
      }
    });

    var drawRecticle = function drawRecticle() {
      if (!(hoveredPoint >= 0)) return;

      var _searchIndex$points$h = searchIndex.points[hoveredPoint].slice(0, 2),
          _searchIndex$points$h2 = _slicedToArray(_searchIndex$points$h, 2),
          x = _searchIndex$points$h2[0],
          y = _searchIndex$points$h2[1]; // Homogeneous coordinates of the point


      var v = [x, y, 0, 1]; // We have to calculate the model-view-projection matrix outside of the
      // shader as we actually don't want the mode, view, or projection of the
      // line view space to change such that the recticle is visualized across the
      // entire view container and not within the view of the scatterplot

      multiply(scratch, projection, multiply(scratch, camera.view, model));
      transformMat4(v, v, scratch);
      recticleHLine.setPoints([-1, v[1], 1, v[1]]);
      recticleVLine.setPoints([v[0], 1, v[0], -1]);
      recticleHLine.draw();
      recticleVLine.draw(); // Draw outer outline

      drawPoints(function () {
        return (pointSizeSelected + pointOutlineWidth * 2) * window.devicePixelRatio;
      }, function () {
        return 1;
      }, hoveredPointIndexBuffer, COLOR_ACTIVE_IDX)(); // Draw inner outline

      drawPoints(function () {
        return (pointSizeSelected + pointOutlineWidth) * window.devicePixelRatio;
      }, function () {
        return 1;
      }, hoveredPointIndexBuffer, COLOR_BG_IDX)();
    };

    var createPointIndex = function createPointIndex(numNewPoints) {
      var index = new Float32Array(numNewPoints);

      for (var i = 0; i < numNewPoints; ++i) {
        index[i] = i;
      }

      return index;
    };

    var createStateTexture = function createStateTexture(newPoints) {
      var numNewPoints = newPoints.length;
      stateTexRes = Math.max(2, Math.ceil(Math.sqrt(numNewPoints)));
      var data = new Float32Array(Math.pow(stateTexRes, 2) * 4);

      for (var i = 0; i < numNewPoints; ++i) {
        data[i * 4] = newPoints[i][0]; // x

        data[i * 4 + 1] = newPoints[i][1]; // y

        data[i * 4 + 2] = newPoints[i][2] || 0; // category

        data[i * 4 + 3] = newPoints[i][3] || 0; // value
      }

      return regl.texture({
        data: data,
        shape: [stateTexRes, stateTexRes, 4],
        type: 'float'
      });
    };

    var cachePoints = function cachePoints(newPoints) {
      if (!stateTex) return false;

      if (isTransitioning) {
        var tmp = prevStateTex;
        prevStateTex = tmpStateTex;
        tmp.destroy();
      } else {
        prevStateTex = stateTex;
      }

      tmpStateTex = createStateTexture(newPoints);
      tmpStateBuffer = regl.framebuffer({
        color: tmpStateTex,
        depth: false,
        stencil: false
      });
      stateTex = undefined;
      return true;
    };

    var clearCachedPoints = function clearCachedPoints() {
      if (prevStateTex) {
        prevStateTex.destroy();
        prevStateTex = undefined;
      }

      if (tmpStateTex) {
        tmpStateTex.destroy();
        tmpStateTex = undefined;
      }
    };

    var setPoints = function setPoints(newPoints) {
      isInit = false;
      numPoints = newPoints.length;
      if (stateTex) stateTex.destroy();
      stateTex = createStateTexture(newPoints);
      normalPointsIndexBuffer({
        usage: 'static',
        type: 'float',
        data: createPointIndex(numPoints)
      });
      searchIndex = new KDBush(newPoints, function (p) {
        return p[0];
      }, function (p) {
        return p[1];
      }, 16);
      isInit = true;
    };

    var draw = function draw(showRecticleOnce) {
      if (!isInit || !regl) return;
      regl.clear({
        // background color (transparent)
        color: [0, 0, 0, 0],
        depth: 1
      }); // Update camera

      isViewChanged = camera.tick();

      if (backgroundImage) {
        drawBackgroundImage();
      } // The draw order of the following calls is important!


      drawPointBodies();
      if (!mouseDown && (showRecticle || showRecticleOnce)) drawRecticle();
      if (hoveredPoint >= 0) drawHoveredPoint();
      if (selection.length) drawSelectedPoint();
      if (lassoPoints.length > 2) drawPolygon2d();
      lasso.draw({
        projection: getProjection(),
        model: getModel(),
        view: getView()
      }); // Publish camera change

      if (isViewChanged) {
        updateScales();
        pubSub.publish('view', {
          view: camera.view,
          camera: camera,
          xScale: xScale,
          yScale: yScale
        });
      }
    };

    var drawHandler = function drawHandler() {
      return pubSub.publish('draw');
    };

    var drawRaf = withRaf(draw, drawHandler);

    var tween = function tween(duration, easing, drawArgs) {
      if (!transitionStartTime) transitionStartTime = performance.now();
      var dt = performance.now() - transitionStartTime;
      updatePoints({
        t: Math.min(1, Math.max(0, easing(dt / duration)))
      });
      draw.apply(drawArgs);
      pubSub.publish('draw');
      return dt < duration;
    };

    var endTransition = function endTransition() {
      isTransitioning = false;
      transitionStartTime = null;
      showRecticle = preTransitionShowRecticle;
      clearCachedPoints();
      pubSub.publish('transitionEnd');
    };

    var transition = function transition(duration, easing, drawArgs) {
      transitionRafId = window.requestAnimationFrame(function () {
        if (tween(duration, easing, drawArgs)) transition(duration, easing, drawArgs);else endTransition();
      });
    };

    var startTransition = function startTransition(_ref3) {
      var _ref3$duration = _ref3.duration,
          duration = _ref3$duration === void 0 ? 500 : _ref3$duration,
          _ref3$easing = _ref3.easing,
          easing = _ref3$easing === void 0 ? DEFAULT_EASING : _ref3$easing;
      var drawArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var easingFn = isString(easing) ? EASING_FNS[easing] || DEFAULT_EASING : easing;

      if (isTransitioning) {
        pubSub.publish('transitionEnd');
        window.cancelAnimationFrame(transitionRafId);
      }

      isTransitioning = true;
      transitionStartTime = null;
      preTransitionShowRecticle = showRecticle;
      showRecticle = false;
      transition(duration, easingFn, drawArgs);
      pubSub.publish('transitionStart');
    };

    var publicDraw = function publicDraw(newPoints) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve) {
        var pointsCached = false;

        if (newPoints) {
          if (options.transition) {
            if (newPoints.length === numPoints) {
              pointsCached = cachePoints(newPoints);
            } else {
              console.warn('Cannot transition! The number of points between the previous and current draw call must be identical.');
            }
          }

          setPoints(newPoints);
        }

        if (transition && pointsCached) {
          pubSub.subscribe('transitionEnd', resolve, 1);
          startTransition({
            duration: options.transitionDuration,
            easing: options.transitionEasing
          }, [options.showRecticleOnce]);
        } else {
          pubSub.subscribe('draw', resolve, 1);
          drawRaf(options.showRecticleOnce);
        }
      });
    };

    var withDraw = function withDraw(f) {
      return function () {
        var out = f.apply(void 0, arguments);
        drawRaf();
        return out;
      };
    };

    var setBackgroundColor = function setBackgroundColor(newBackgroundColor) {
      if (!newBackgroundColor) return;
      backgroundColor = toRgba(newBackgroundColor, true);
    };

    var setBackgroundImage = function setBackgroundImage(newBackgroundImage) {
      if (!newBackgroundImage) {
        backgroundImage = null;
      } else if (isString(newBackgroundImage)) {
        createTextureFromUrl(regl, newBackgroundImage).then(function (texture) {
          backgroundImage = texture;
          drawRaf();
          pubSub.publish('backgroundImageReady');
        });
      } else {
        backgroundImage = newBackgroundImage;
      }
    };

    var setCameraDistance = function setCameraDistance(distance) {
      if (distance > 0) camera.lookAt(camera.target, distance, camera.rotation);
    };

    var setCameraRotation = function setCameraRotation(rotation) {
      if (rotation !== null) camera.lookAt(camera.target, camera.distance, rotation);
    };

    var setCameraTarget = function setCameraTarget(target) {
      if (target) camera.lookAt(target, camera.distance, camera.rotation);
    };

    var setCameraView = function setCameraView(view) {
      if (view) camera.setView(view);
    };

    var setLassoColor = function setLassoColor(newLassoColor) {
      if (!newLassoColor) return;
      lassoColor = toRgba(newLassoColor, true);
      lasso.setStyle({
        color: lassoColor
      });
    };

    var setLassoMinDelay = function setLassoMinDelay(newLassoMinDelay) {
      if (!+newLassoMinDelay) return;
      lassoMinDelay = +newLassoMinDelay;
      lassoExtendDb = throttle(lassoExtend, lassoMinDelay);
    };

    var setLassoMinDist = function setLassoMinDist(newLassoMinDist) {
      if (!+newLassoMinDist) return;
      lassoMinDist = +newLassoMinDist;
    };

    var setLassoClearEvent = function setLassoClearEvent(newLassoClearEvent) {
      lassoClearEvent = limit(LASSO_CLEAR_EVENTS, lassoClearEvent)(newLassoClearEvent);
    };

    var setShowRecticle = function setShowRecticle(newShowRecticle) {
      if (newShowRecticle === null) return;
      showRecticle = newShowRecticle;
    };

    var setRecticleColor = function setRecticleColor(newRecticleColor) {
      if (!newRecticleColor) return;
      recticleColor = toRgba(newRecticleColor, true);
      recticleHLine.setStyle({
        color: recticleColor
      });
      recticleVLine.setStyle({
        color: recticleColor
      });
    };

    var setXScale = function setXScale(newXScale) {
      if (!newXScale) return;
      xScale = newXScale;
      xDomainStart = newXScale.domain()[0];
      xDomainSize = newXScale ? newXScale.domain()[1] - newXScale.domain()[0] : 0;
    };

    var setYScale = function setYScale(newYScale) {
      if (!newYScale) return;
      yScale = newYScale;
      yDomainStart = yScale.domain()[0];
      yDomainSize = yScale ? yScale.domain()[1] - yScale.domain()[0] : 0;
    };

    var setDeselectOnDblClick = function setDeselectOnDblClick(newDeselectOnDblClick) {
      deselectOnDblClick = !!newDeselectOnDblClick;
    };

    var setDeselectOnEscape = function setDeselectOnEscape(newDeselectOnEscape) {
      deselectOnEscape = !!newDeselectOnEscape;
    };
    /**
     * Update Regl's viewport, drawingBufferWidth, and drawingBufferHeight
     *
     * @description Call this method after the viewport has changed, e.g., width
     * or height have been altered
     */


    var refresh = function refresh() {
      regl.poll();
      camera.refresh();
    };

    var get = function get(property) {
      checkDeprecations({
        property: true
      });
      if (property === 'aspectRatio') return dataAspectRatio;
      if (property === 'background') return backgroundColor;
      if (property === 'backgroundColor') return backgroundColor;
      if (property === 'backgroundImage') return backgroundImage;
      if (property === 'camera') return camera;
      if (property === 'cameraTarget') return camera.target;
      if (property === 'cameraDistance') return camera.distance;
      if (property === 'cameraRotation') return camera.rotation;
      if (property === 'cameraView') return camera.view;
      if (property === 'canvas') return canvas;
      if (property === 'colorBy') return colorBy;
      if (property === 'sizeBy') return sizeBy;
      if (property === 'deselectOnDblClick') return deselectOnDblClick;
      if (property === 'deselectOnEscape') return deselectOnEscape;
      if (property === 'height') return height;
      if (property === 'lassoColor') return lassoColor;
      if (property === 'lassoMinDelay') return lassoMinDelay;
      if (property === 'lassoMinDist') return lassoMinDist;
      if (property === 'lassoClearEvent') return lassoClearEvent;
      if (property === 'opacity') return opacity;
      if (property === 'pointColor') return pointColors.length === 1 ? pointColors[0] : pointColors;
      if (property === 'pointColorActive') return pointColorsActive.length === 1 ? pointColorsActive[0] : pointColorsActive;
      if (property === 'pointColorHover') return pointColorsHover.length === 1 ? pointColorsHover[0] : pointColorsHover;
      if (property === 'pointOutlineWidth') return pointOutlineWidth;
      if (property === 'pointSize') return pointSize;
      if (property === 'pointSizeSelected') return pointSizeSelected;
      if (property === 'recticleColor') return recticleColor;
      if (property === 'regl') return regl;
      if (property === 'showRecticle') return showRecticle;
      if (property === 'version') return version;
      if (property === 'width') return width;
      if (property === 'xScale') return xScale;
      if (property === 'yScale') return yScale;
      return undefined;
    };

    var set = function set() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      checkDeprecations(properties);

      if (properties.backgroundColor !== undefined || properties.background !== undefined) {
        setBackgroundColor(properties.backgroundColor || properties.background);
      }

      if (properties.backgroundImage !== undefined) {
        setBackgroundImage(properties.backgroundImage);
      }

      if (properties.cameraTarget !== undefined) {
        setCameraTarget(properties.cameraTarget);
      }

      if (properties.cameraDistance !== undefined) {
        setCameraDistance(properties.cameraDistance);
      }

      if (properties.cameraRotation !== undefined) {
        setCameraRotation(properties.cameraRotation);
      }

      if (properties.cameraView !== undefined) {
        setCameraView(properties.cameraView);
      }

      if (properties.colorBy !== undefined) {
        setColorBy(properties.colorBy);
      }

      if (properties.pointColor !== undefined) {
        setPointColors(properties.pointColor);
      }

      if (properties.pointColorActive !== undefined) {
        setPointColorsActive(properties.pointColorActive);
      }

      if (properties.pointColorHover !== undefined) {
        setPointColorsHover(properties.pointColorHover);
      }

      if (properties.pointSize !== undefined) {
        setPointSize(properties.pointSize);
      }

      if (properties.pointSizeSelected !== undefined) {
        setPointSizeSelected(properties.pointSizeSelected);
      }

      if (properties.sizeBy !== undefined) {
        setSizeBy(properties.sizeBy);
      }

      if (properties.opacity !== undefined) {
        setOpacity(properties.opacity);
      }

      if (properties.lassoColor !== undefined) {
        setLassoColor(properties.lassoColor);
      }

      if (properties.lassoMinDelay !== undefined) {
        setLassoMinDelay(properties.lassoMinDelay);
      }

      if (properties.lassoMinDist !== undefined) {
        setLassoMinDist(properties.lassoMinDist);
      }

      if (properties.lassoClearEvent !== undefined) {
        setLassoClearEvent(properties.lassoClearEvent);
      }

      if (properties.showRecticle !== undefined) {
        setShowRecticle(properties.showRecticle);
      }

      if (properties.recticleColor !== undefined) {
        setRecticleColor(properties.recticleColor);
      }

      if (properties.pointOutlineWidth !== undefined) {
        setPointOutlineWidth(properties.pointOutlineWidth);
      }

      if (properties.height !== undefined) {
        setHeight(properties.height);
      }

      if (properties.width !== undefined) {
        setWidth(properties.width);
      }

      if (properties.aspectRatio !== undefined) {
        setDataAspectRatio(properties.aspectRatio);
      }

      if (properties.xScale !== undefined) {
        setXScale(properties.xScale);
      }

      if (properties.yScale !== undefined) {
        setYScale(properties.yScale);
      }

      if (properties.deselectOnDblClick !== undefined) {
        setDeselectOnDblClick(properties.deselectOnDblClick);
      }

      if (properties.deselectOnEscape !== undefined) {
        setDeselectOnEscape(properties.deselectOnEscape);
      }

      updateViewAspectRatio();
      camera.refresh();
      refresh();
      drawRaf();
    };

    var hover = function hover(point) {
      var showRecticleOnce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var needsRedraw = false;

      if (point >= 0) {
        needsRedraw = true;
        var newHoveredPoint = point !== hoveredPoint;
        hoveredPoint = point;
        hoveredPointIndexBuffer.subdata([point]);
        if (newHoveredPoint) pubSub.publish('pointover', hoveredPoint);
      } else {
        needsRedraw = hoveredPoint;
        hoveredPoint = undefined;
        if (+needsRedraw >= 0) pubSub.publish('pointout', needsRedraw);
      }

      if (needsRedraw) drawRaf(null, showRecticleOnce);
    };

    var initCamera = function initCamera() {
      if (!camera) camera = dom2dCamera(canvas);

      if (initialCameraView || initialView) {
        camera.setView(clone(initialCameraView || initialView));
      } else if (initialCameraTarget || initialTarget || initialCameraDistance || initialDistance || initialCameraRotation || initialRotation) {
        camera.lookAt(_toConsumableArray(initialCameraTarget || initialTarget || DEFAULT_TARGET), initialCameraDistance || initialDistance || DEFAULT_DISTANCE, initialCameraRotation || initialRotation || DEFAULT_ROTATION);
      } else {
        camera.setView(clone(DEFAULT_VIEW));
      }
    };

    var reset = function reset() {
      initCamera();
      updateScales();
      pubSub.publish('view', {
        view: camera.view,
        camera: camera,
        xScale: xScale,
        yScale: yScale
      });
    };

    var keyUpHandler = function keyUpHandler(_ref4) {
      var key = _ref4.key;

      switch (key) {
        case 'Escape':
          if (deselectOnEscape) deselect();
          break;

      }
    };

    var mouseEnterCanvasHandler = function mouseEnterCanvasHandler() {
      isMouseInCanvas = true;
    };

    var mouseLeaveCanvasHandler = function mouseLeaveCanvasHandler() {
      hover();
      isMouseInCanvas = false;
      drawRaf();
    };

    var wheelHandler = function wheelHandler() {
      drawRaf();
    };

    var clear = function clear() {
      setPoints([]);
    };

    var init = function init() {
      updateViewAspectRatio();
      initCamera();
      updateScales();
      lasso = createLine(regl, {
        color: lassoColor,
        width: 3,
        is2d: true
      });
      recticleHLine = createLine(regl, {
        color: recticleColor,
        width: 1,
        is2d: true
      });
      recticleVLine = createLine(regl, {
        color: recticleColor,
        width: 1,
        is2d: true
      }); // Event listeners

      canvas.addEventListener('wheel', wheelHandler); // Buffers

      normalPointsIndexBuffer = regl.buffer();
      selectedPointsIndexBuffer = regl.buffer();
      hoveredPointIndexBuffer = regl.buffer({
        usage: 'dynamic',
        type: 'float',
        length: FLOAT_BYTES$1 // This buffer is fixed to exactly 1 point

      });
      colorTex = createColorTexture();
      pointSizeTex = createPointSizeTexture(); // Set dimensions

      set({
        backgroundImage: initialBackgroundImage,
        width: width,
        height: height
      }); // Setup event handler

      window.addEventListener('keyup', keyUpHandler, false);
      window.addEventListener('blur', blurHandler, false);
      window.addEventListener('mouseup', mouseUpHandler, false);
      window.addEventListener('mousemove', mouseMoveHandler, false);
      canvas.addEventListener('mousedown', mouseDownHandler, false);
      canvas.addEventListener('mouseenter', mouseEnterCanvasHandler, false);
      canvas.addEventListener('mouseleave', mouseLeaveCanvasHandler, false);
      canvas.addEventListener('click', mouseClickHandler, false);
      canvas.addEventListener('dblclick', mouseDblClickHandler, false);
    };

    var destroy = function destroy() {
      window.removeEventListener('keyup', keyUpHandler, false);
      window.removeEventListener('blur', blurHandler, false);
      window.removeEventListener('mouseup', mouseUpHandler, false);
      window.removeEventListener('mousemove', mouseMoveHandler, false);
      canvas.removeEventListener('mousedown', mouseDownHandler, false);
      canvas.removeEventListener('mouseenter', mouseEnterCanvasHandler, false);
      canvas.removeEventListener('mouseleave', mouseLeaveCanvasHandler, false);
      canvas.removeEventListener('click', mouseClickHandler, false);
      canvas.removeEventListener('dblclick', mouseDblClickHandler, false);
      canvas = undefined;
      camera = undefined;
      regl = undefined;
      lasso.destroy();
      pubSub.clear();
    };

    init();
    return {
      clear: withDraw(clear),
      createTextureFromUrl: function createTextureFromUrl$1(url) {
        return createTextureFromUrl(regl, url);
      },
      deselect: deselect,
      destroy: destroy,
      draw: publicDraw,
      get: get,
      hover: hover,
      refresh: refresh,
      reset: withDraw(reset),
      select: select,
      set: set,
      subscribe: pubSub.subscribe,
      unsubscribe: pubSub.unsubscribe
    };
  };

  exports.createRegl = createRegl;
  exports.createTextureFromUrl = createTextureFromUrl;
  exports.default = createScatterplot;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
