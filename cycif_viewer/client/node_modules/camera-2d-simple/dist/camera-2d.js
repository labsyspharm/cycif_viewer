(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('gl-matrix')) :
  typeof define === 'function' && define.amd ? define(['gl-matrix'], factory) :
  (global = global || self, global.createCamera2d = factory(global.glMatrix));
}(this, (function (glMatrix) { 'use strict';

  var createCamera = function (
    initTarget,
    initDistance,
    initRotation,
    initViewCenter,
    initScaleBounds
  ) {
    if ( initTarget === void 0 ) initTarget = [0, 0];
    if ( initDistance === void 0 ) initDistance = 1;
    if ( initRotation === void 0 ) initRotation = 0;
    if ( initViewCenter === void 0 ) initViewCenter = [0, 0];
    if ( initScaleBounds === void 0 ) initScaleBounds = [0, Infinity];

    // Scratch variables
    var scratch0 = new Float32Array(16);
    var scratch1 = new Float32Array(16);
    var scratch2 = new Float32Array(16);

    var view = glMatrix.mat4.create();
    var viewCenter = initViewCenter.slice(0, 2).concat( [0], [1]);

    var scaleBounds = [].concat( initScaleBounds );

    var getRotation = function () { return Math.acos(view[0] / getScaling()); };

    var getScaling = function () { return glMatrix.mat4.getScaling(scratch0, view)[0]; };

    var getScaleBounds = function () { return [].concat( scaleBounds ); };

    var getDistance = function () { return 1 / getScaling(); };

    var getTranslation = function () { return glMatrix.mat4.getTranslation(scratch0, view).slice(0, 2); };

    var getTarget = function () { return glMatrix.vec4
        .transformMat4(scratch0, viewCenter, glMatrix.mat4.invert(scratch2, view))
        .slice(0, 2); };

    var getView = function () { return view; };

    var getViewCenter = function () { return viewCenter.slice(0, 2); };

    var lookAt = function (ref, newDistance, newRotation) {
      if ( ref === void 0 ) ref = [];
      var x = ref[0]; if ( x === void 0 ) x = 0;
      var y = ref[1]; if ( y === void 0 ) y = 0;
      if ( newDistance === void 0 ) newDistance = 1;
      if ( newRotation === void 0 ) newRotation = 0;

      // Reset the view
      view = glMatrix.mat4.create();

      translate([-x, -y]);
      rotate(newRotation);
      scale(1 / newDistance);
    };

    var translate = function (ref) {
      if ( ref === void 0 ) ref = [];
      var x = ref[0]; if ( x === void 0 ) x = 0;
      var y = ref[1]; if ( y === void 0 ) y = 0;

      scratch0[0] = x;
      scratch0[1] = y;
      scratch0[2] = 0;

      var t = glMatrix.mat4.fromTranslation(scratch1, scratch0);

      // Translate about the viewport center
      // This is identical to `i * t * i * view` where `i` is the identity matrix
      glMatrix.mat4.multiply(view, t, view);
    };

    var scale = function (d, mousePos) {
      if (d <= 0) { return; }

      var scale = getScaling();
      var newScale = scale * d;

      d = Math.max(scaleBounds[0], Math.min(newScale, scaleBounds[1])) / scale;

      if (d === 1) { return; } // There is nothing to do

      scratch0[0] = d;
      scratch0[1] = d;
      scratch0[2] = 1;

      var s = glMatrix.mat4.fromScaling(scratch1, scratch0);

      var scaleCenter = mousePos ? mousePos.concat( [0]) : viewCenter;
      var a = glMatrix.mat4.fromTranslation(scratch0, scaleCenter);

      // Translate about the scale center
      // I.e., the mouse position or the view center
      glMatrix.mat4.multiply(
        view,
        a,
        glMatrix.mat4.multiply(
          view,
          s,
          glMatrix.mat4.multiply(view, glMatrix.mat4.invert(scratch2, a), view)
        )
      );
    };

    var rotate = function (rad) {
      var r = glMatrix.mat4.create();
      glMatrix.mat4.fromRotation(r, rad, [0, 0, 1]);

      // Rotate about the viewport center
      // This is identical to `i * r * i * view` where `i` is the identity matrix
      glMatrix.mat4.multiply(view, r, view);
    };

    var setScaleBounds = function (newBounds) {
      scaleBounds[0] = newBounds[0];
      scaleBounds[1] = newBounds[1];
    };

    var setView = function (newView) {
      if (!newView || newView.length < 16) { return; }
      view = newView;
    };

    var setViewCenter = function (newViewCenter) {
      viewCenter = newViewCenter.slice(0, 2).concat( [0], [1]);
    };

    var reset = function () {
      lookAt(initTarget, initDistance, initRotation);
    };

    // Init
    lookAt(initTarget, initDistance, initRotation);

    return {
      get translation() {
        return getTranslation();
      },
      get target() {
        return getTarget();
      },
      get scaling() {
        return getScaling();
      },
      get scaleBounds() {
        return getScaleBounds();
      },
      get distance() {
        return getDistance();
      },
      get rotation() {
        return getRotation();
      },
      get view() {
        return getView();
      },
      get viewCenter() {
        return getViewCenter();
      },
      lookAt: lookAt,
      translate: translate,
      pan: translate,
      rotate: rotate,
      scale: scale,
      zoom: scale,
      reset: reset,
      set: function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        console.warn("`set()` is deprecated. Please use `setView()` instead.");
        return setView.apply(void 0, args);
      },
      setScaleBounds: setScaleBounds,
      setView: setView,
      setViewCenter: setViewCenter
    };
  };

  return createCamera;

})));
