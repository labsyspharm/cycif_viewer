!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):e.createLine=n()}(this,function(){"use strict";var e=Array.prototype,n=e.push,r=e.unshift,t=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),o=Float32Array.BYTES_PER_ELEMENT,i=function(e,r,t){void 0===r&&(r=1),void 0===t&&(t=1);for(var o=[],i=new Array(2*r),c=0,a=e.length/r;c<a;c++){for(var d=c*r,u=0;u<r;u++){var l=e[d+u];i[u]=l,i[u+r]=l*t}n.apply(o,i)}return o},c=function(e,r,t){for(var o=new Array(t),i=r*t,c=0;c<t;c++)o[c]=e[i+c];return n.apply(e,o),e},a=function(e,n,t){for(var o=new Array(t),i=n*t,c=0;c<t;c++)o[c]=e[i+c];return r.apply(e,o),e},d=function(e,r,t,o){void 0===o&&(o=0);for(var i=[],c=new Array(t).fill(o),a=0,d=e.length/r;a<d;a++){for(var u=a*r,l=0;l<r;l++)c[l]=e[u+l];n.apply(i,c)}return i};return function(e,n){void 0===n&&(n={});var r=n.projection;void 0===r&&(r=t);var u=n.model;void 0===u&&(u=t);var l=n.view;void 0===l&&(l=t);var v=n.points;void 0===v&&(v=[]);var f=n.widths;void 0===f&&(f=[]);var s=n.color;void 0===s&&(s=[.8,.5,0,1]);var p=n.width;void 0===p&&(p=1);var m=n.miter;void 0===m&&(m=1);var h=n.is2d;void 0===h&&(h=!1);var w=n.zPos2d;if(void 0===w&&(w=0),e){var g,y,j,P,x,S,A,b,R,B,V,z=h?2:3,M=function(){A=e.buffer(),b=e.buffer(),R={prevPosition:{buffer:function(){return A},offset:0,stride:3*o},currPosition:{buffer:function(){return A},offset:3*o*2,stride:3*o},nextPosition:{buffer:function(){return A},offset:3*o*4,stride:3*o},offsetScale:function(){return b}},B=e.elements(),V=e({attributes:R,depth:{enable:!h},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:"one",dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"}},uniforms:{projection:function(e,n){return e.projection||n.projection},model:function(e,n){return e.model||n.model},view:function(e,n){return e.view||n.view},aspectRatio:function(e){return e.viewportWidth/e.viewportHeight},color:function(){return s},width:function(e){var n=e.viewportWidth;return p/n*window.devicePixelRatio},miter:m},elements:function(){return B},vert:"\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspectRatio;\n\nuniform float width;\nuniform int miter;\n\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\nattribute float offsetScale;\n\nvoid main() {\n  vec2 aspectVec = vec2(aspectRatio, 1.0);\n  mat4 projViewModel = projection * view * model;\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected.xy / prevProjected.w * aspectVec;\n  vec2 currScreen = currProjected.xy / currProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n\n  // starting point uses (next - current)\n  vec2 dir = vec2(0.0);\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (miter == 1) {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n    } else {\n      dir = dirA;\n    }\n  }\n\n  vec2 normal = vec2(-dir.y, dir.x) * width;\n  normal.x /= aspectRatio;\n  vec4 offset = vec4(normal * offsetScale, 0.0, 0.0);\n  gl_Position = currProjected + offset;\n}",frag:"\nprecision mediump float;\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}"})},E=function(){F(),M()},F=function(){v=null,j=null,P=null,x=null,S=null,A.destroy(),b.destroy(),B.destroy()},_=function(e,n,r){void 0===e&&(e=[]),void 0===n&&(n=f),void 0===r&&(r=h),v=e,z=(h=r)?2:3,g=Math.floor(v.length/z),y=g+2,n.length===g&&(f=n),v&&v.length>1?(v.length%z>0&&console.warn("The length of points ("+g+") does not match the dimensions ("+z+"). Incomplete points are ignored."),j=v.slice(0,g*z),h&&(j=d(j,2,3,w)),f.length!==g&&(f=new Array(g).fill(1)),c(j,g-1,3),a(j,0,3),P=new Float32Array(i(j,3)),x=i(f,1,-1),S=function(e,n,r){void 0===r&&(r=[]);for(var t=0;t<e-1;t++){var o=n+2*t,i=o+1,c=o+2,a=o+3;r.push(o,i,c,c,i,a)}return r}(g,0),A({usage:"dynamic",type:"float",length:3*y*2*o,data:P}),b({usage:"dynamic",type:"float",length:1*g*2*o,data:x}),B({primitive:"triangles",usage:"dynamic",type:"uint16",data:S})):E()};return M(),v&&v.length>1&&_(v),{clear:E,destroy:F,draw:function(e){void 0===e&&(e={});var n=e.projection,t=e.model,o=e.view;n&&(r=n),t&&(u=t),o&&(l=o),v&&v.length>1&&V({projection:r,model:u,view:l})},getPoints:function(){return v},setPoints:_,getData:function(){return{points:P,widths:x}},getBuffer:function(){return{points:A,widths:b}},getStyle:function(){return{color:s,miter:m,width:p}},setStyle:function(e){void 0===e&&(e={});var n=e.color,r=e.miter,t=e.width;n&&(s=n),r&&(m=r),+t>0&&(p=t)}}}console.error("Regl instance is undefined.")}});
