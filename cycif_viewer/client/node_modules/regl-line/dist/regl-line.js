(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.createLine = factory());
}(this, (function () { 'use strict';

  var FRAGMENT_SHADER = "\nprecision mediump float;\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}";

  // Vertex shader from https://mattdesl.svbtle.com/drawing-lines-is-hard
  // The MIT License (MIT) Copyright (c) 2015 Matt DesLauriers
  var VERTEX_SHADER = "\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform float aspectRatio;\n\nuniform float width;\nuniform int miter;\n\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\nattribute float offsetScale;\n\nvoid main() {\n  vec2 aspectVec = vec2(aspectRatio, 1.0);\n  mat4 projViewModel = projection * view * model;\n  vec4 prevProjected = projViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projViewModel * vec4(nextPosition, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected.xy / prevProjected.w * aspectVec;\n  vec2 currScreen = currProjected.xy / currProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n\n  // starting point uses (next - current)\n  vec2 dir = vec2(0.0);\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (miter == 1) {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n    } else {\n      dir = dirA;\n    }\n  }\n\n  vec2 normal = vec2(-dir.y, dir.x) * width;\n  normal.x /= aspectRatio;\n  vec4 offset = vec4(normal * offsetScale, 0.0, 0.0);\n  gl_Position = currProjected + offset;\n}";

  var ref = Array.prototype;
  var push = ref.push;
  var unshift = ref.unshift;

  var I = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var FLOAT_BYTES = Float32Array.BYTES_PER_ELEMENT;

  var createMesh = function (numPoints, width, buffer) {
    if ( buffer === void 0 ) buffer = [];

    for (var i = 0; i < numPoints - 1; i++) {
      var a = width + i * 2;
      var b = a + 1;
      var c = a + 2;
      var d = a + 3;
      buffer.push(a, b, c, c, b, d);
    }
    return buffer;
  };

  var buffer = {
    duplicate: function duplicate(buffer, stride, dupScale) {
      if ( stride === void 0 ) stride = 1;
      if ( dupScale === void 0 ) dupScale = 1;

      var out = [];
      var component = new Array(stride * 2);
      for (var i = 0, il = buffer.length / stride; i < il; i++) {
        var index = i * stride;
        for (var j = 0; j < stride; j++) {
          var value = buffer[index + j];
          component[j] = value;
          component[j + stride] = value * dupScale;
        }
        push.apply(out, component);
      }
      return out;
    },

    mapElement: function mapElement(buffer, elementIndex, stride, map) {
      for (var i = 0, il = buffer.length / stride; i < il; i++) {
        var index = elementIndex + i * stride;
        buffer[index] = map(buffer[index], index, i);
      }
      return buffer;
    },

    pushElement: function pushElement(buffer, elementIndex, stride) {
      var component = new Array(stride);
      var ai = elementIndex * stride;
      for (var i = 0; i < stride; i++) {
        component[i] = buffer[ai + i];
      }
      push.apply(buffer, component);
      return buffer;
    },

    // Copy a component to the beginning of the buffer
    unshiftElement: function unshiftElement(buffer, elementIndex, stride) {
      var component = new Array(stride);
      var ai = elementIndex * stride;
      for (var i = 0; i < stride; i++) {
        component[i] = buffer[ai + i];
      }
      unshift.apply(buffer, component);
      return buffer;
    },

    increaseStride: function increaseStride(buffer, stride, newStride, undefValue) {
      if ( undefValue === void 0 ) undefValue = 0;

      var out = [];
      var component = new Array(newStride).fill(undefValue);
      for (var i = 0, il = buffer.length / stride; i < il; i++) {
        var index = i * stride;
        for (var j = 0; j < stride; j++) {
          component[j] = buffer[index + j];
        }
        push.apply(out, component);
      }
      return out;
    }
  };

  var createLine = function (
    regl,
    ref
  ) {
    if ( ref === void 0 ) ref = {};
    var projection = ref.projection; if ( projection === void 0 ) projection = I;
    var model = ref.model; if ( model === void 0 ) model = I;
    var view = ref.view; if ( view === void 0 ) view = I;
    var points = ref.points; if ( points === void 0 ) points = [];
    var widths = ref.widths; if ( widths === void 0 ) widths = [];
    var color = ref.color; if ( color === void 0 ) color = [0.8, 0.5, 0, 1];
    var width = ref.width; if ( width === void 0 ) width = 1;
    var miter = ref.miter; if ( miter === void 0 ) miter = 1;
    var is2d = ref.is2d; if ( is2d === void 0 ) is2d = false;
    var zPos2d = ref.zPos2d; if ( zPos2d === void 0 ) zPos2d = 0;

    if (!regl) {
      console.error("Regl instance is undefined.");
      return;
    }

    var numPoints;
    var numPointsTotal;
    var pointsPadded;
    var pointsDup;
    var widthsDup;
    var indices;
    var pointBuffer;
    var widthBuffer;
    var attributes;
    var elements;
    var drawLine;

    var dim = is2d ? 2 : 3;

    var init = function () {
      pointBuffer = regl.buffer();

      widthBuffer = regl.buffer();

      attributes = {
        prevPosition: {
          buffer: function () { return pointBuffer; },
          offset: 0,
          stride: FLOAT_BYTES * 3
        },
        currPosition: {
          buffer: function () { return pointBuffer; },
          // note that each point is duplicated, hence we need to skip over the first two
          offset: FLOAT_BYTES * 3 * 2,
          stride: FLOAT_BYTES * 3
        },
        nextPosition: {
          buffer: function () { return pointBuffer; },
          // note that each point is duplicated, hence we need to skip over the first four
          offset: FLOAT_BYTES * 3 * 4,
          stride: FLOAT_BYTES * 3
        },
        offsetScale: function () { return widthBuffer; }
      };

      elements = regl.elements();

      drawLine = regl({
        attributes: attributes,
        depth: { enable: !is2d },
        blend: {
          enable: true,
          func: {
            srcRGB: "src alpha",
            srcAlpha: "one",
            dstRGB: "one minus src alpha",
            dstAlpha: "one minus src alpha"
          }
        },
        uniforms: {
          projection: function (context, props) { return context.projection || props.projection; },
          model: function (context, props) { return context.model || props.model; },
          view: function (context, props) { return context.view || props.view; },
          aspectRatio: function (ref) {
              var viewportWidth = ref.viewportWidth;
              var viewportHeight = ref.viewportHeight;

              return viewportWidth / viewportHeight;
      },
          color: function () { return color; },
          width: function (ref) {
              var viewportWidth = ref.viewportWidth;

              return (width / viewportWidth) * window.devicePixelRatio;
      },
          miter: miter
        },
        elements: function () { return elements; },
        vert: VERTEX_SHADER,
        frag: FRAGMENT_SHADER
      });
    };

    var prepare = function () {
      if (points.length % dim > 0) {
        console.warn(
          ("The length of points (" + numPoints + ") does not match the dimensions (" + dim + "). Incomplete points are ignored.")
        );
      }

      // Copy all points belonging to complete points
      pointsPadded = points.slice(0, numPoints * dim);

      // Add the missing z point
      if (is2d) {
        pointsPadded = buffer.increaseStride(pointsPadded, 2, 3, zPos2d);
      }

      if (widths.length !== numPoints) { widths = new Array(numPoints).fill(1); }

      // duplicate the first and last point. E.g., [1,2,3] -> [1,1,2,3,3]
      // copy the last point to the end
      buffer.pushElement(pointsPadded, numPoints - 1, 3);
      // copy the first point to the beginning
      buffer.unshiftElement(pointsPadded, 0, 3);

      // duplicate each point for the positive and negative width (see below)
      pointsDup = new Float32Array(buffer.duplicate(pointsPadded, 3));
      // duplicate each width such that we have a positive and negative width
      widthsDup = buffer.duplicate(widths, 1, -1);
      // create the line mesh, i.e., the vertex indices
      indices = createMesh(numPoints, 0);

      pointBuffer({
        usage: "dynamic",
        type: "float",
        // 3 because its a 3-vector and 2 because each point is duplicated
        length: numPointsTotal * 3 * 2 * FLOAT_BYTES,
        data: pointsDup
      });

      widthBuffer({
        usage: "dynamic",
        type: "float",
        // 1 because its a scalar and 2 because each width is duplicated
        length: numPoints * 1 * 2 * FLOAT_BYTES,
        data: widthsDup
      });

      elements({
        primitive: "triangles",
        usage: "dynamic",
        type: "uint16",
        data: indices
      });
    };

    var clear = function () {
      destroy();
      init();
    };

    var destroy = function () {
      points = null;
      pointsPadded = null;
      pointsDup = null;
      widthsDup = null;
      indices = null;
      pointBuffer.destroy();
      widthBuffer.destroy();
      elements.destroy();
    };

    var draw = function (ref) {
      if ( ref === void 0 ) ref = {};
      var newProjection = ref.projection;
      var newModel = ref.model;
      var newView = ref.view;

      // cache the view-defining matrices
      if (newProjection) {
        projection = newProjection;
      }
      if (newModel) {
        model = newModel;
      }
      if (newView) {
        view = newView;
      }
      // only draw when some points have been specified
      if (points && points.length > 1) {
        drawLine({ projection: projection, model: model, view: view });
      }
    };

    var getPoints = function () { return points; };

    var setPoints = function (newPoints, newWidths, newIs2d) {
      if ( newPoints === void 0 ) newPoints = [];
      if ( newWidths === void 0 ) newWidths = widths;
      if ( newIs2d === void 0 ) newIs2d = is2d;

      points = newPoints;
      is2d = newIs2d;

      dim = is2d ? 2 : 3;
      numPoints = Math.floor(points.length / dim);
      numPointsTotal = numPoints + 2;

      if (newWidths.length === numPoints) { widths = newWidths; }

      if (points && points.length > 1) {
        prepare();
      } else {
        clear();
      }
    };

    var getStyle = function () { return ({ color: color, miter: miter, width: width }); };

    var setStyle = function (ref) {
      if ( ref === void 0 ) ref = {};
      var newColor = ref.color;
      var newMiter = ref.miter;
      var newWidth = ref.width;

      if (newColor) { color = newColor; }
      if (newMiter) { miter = newMiter; }
      if (+newWidth > 0) { width = newWidth; }
    };

    var getBuffer = function () { return ({
      points: pointBuffer,
      widths: widthBuffer
    }); };

    var getData = function () { return ({
      points: pointsDup,
      widths: widthsDup
    }); };

    // initialize parameters
    init();

    // prepare data if points are already specified
    if (points && points.length > 1) {
      setPoints(points);
    }

    return {
      clear: clear,
      destroy: destroy,
      draw: draw,
      getPoints: getPoints,
      setPoints: setPoints,
      getData: getData,
      getBuffer: getBuffer,
      getStyle: getStyle,
      setStyle: setStyle
    };
  };

  return createLine;

})));
